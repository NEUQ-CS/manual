{"/get-started/":{"data":{"":" Markdown 短代码 计算机类篇 电子信息类篇 算法入门 电子信息类-保研 "},"title":"基础篇"},"/get-started/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E7%B1%BB-%E4%BF%9D%E7%A0%94/":{"data":{"neuq电子信息类保研-最全面的规则解读与攻略#NEUQ电子信息类保研-最全面的规则解读与攻略":"","一前言#一、前言":"","三保研政策-胎教级分析保研er必读#三、保研政策-胎教级分析（保研er必读）":"","二学长学姐的保研去向#二、学长学姐的保研去向":"","五关于科研和论文#五、关于科研和论文":"","六关于竞赛#六、关于竞赛":"NEUQ电子信息类保研-最全面的规则解读与攻略一、前言 ​\t相信很多新同学最关心的问题就是关于升学，保研。接下来的部分将为大家用最通俗易懂的语言解读我们学校的保研政策，并且清晰地给出最明确的指导和规划。在此之前先叠个甲：大学里每个人有不同的路，考公、就业、考研、继承家产等等，走保研这条赛道的毕竟是少数人，此篇仅面向有意向卷保研的同学。文中有任何表述不妥可联系本人修正。（虽然标题是电子信息类保研，实际上其中的内容所有计工同学都可以拿来参考）\n二、学长学姐的保研去向 ​\t这里给出19级、20级计工学长学姐的保研去向，你也许可以比他们做得更好，但基本上不会相差太多，可以作为参考，保研毕竟是一个保底，上限肯定不如考研高，如果对这些去向觉得不够满意的话，可以早早地开始规划考研哦。\n19级保研去向： 序号 专业 院校 专业 类型 1 计算机科学与技术 武汉大学 计算机科学与技术 学术型 2 计算机科学与技术 东北大学 计算机科学与技术 学术型 3 计算机科学与技术 武汉大学 人工智能 学术型 4 计算机科学与技术 华中科技大学 人工智能 学术型 5 计算机科学与技术 浙江大学 电子信息 专业型 6 计算机科学与技术 西安交通大学 计算机技术 专业型 7 计算机科学与技术 华中科技大学 计算机科学与技术 学术型 8 计算机科学与技术 武汉大学 人工智能 学术型 9 计算机科学与技术 西安交通大学 人工智能 学术型 10 计算机科学与技术 西安交通大学 软件工程 专业型 11 计算机科学与技术 国防科技大学 电子信息 专业性 12 计算机科学与技术 中国科学院大学 计算机应用技术 学术型 13 计算机科学与技术 北京大学 电子信息-计算机技术 专业型 14 计算机科学与技术 东北大学 计算机科学与技术 学术型 15 计算机科学与技术 东北大学 计算机科学与技术 专业型 16 计算机科学与技术 东北大学 计算机科学与技术 学术型 17 计算机科学与技术 武汉大学 网络空间安全 学术型 18 计算机科学与技术 北京交通大学 计算机科学与技术 学术型 19 物联网工程 天津大学 电子信息 专业型 20 物联网工程 武汉大学 网络空间安全 学术型 21 电子信息工程 东北大学 计算机科学与技术 学术型 22 电子信息工程 西北工业大学 信息与通信工程 学术型 23 电子信息工程 武汉大学 电子信息 专业型 24 电子信息工程 电子科技大学 信息与通信工程 学术型 25 电子信息工程 浙江大学 信息与通信工程 学术型 26 电子信息工程 电子科技大学 信息与通信工程 学术型 27 电子信息工程 西安交通大学 电子信息 专业型 28 电子信息工程 东南大学 电子信息 专业型 29 电子信息工程 北京理工大学 光电信息工程 专业型 30 电子信息工程 中国科学技术大学 电子信息（计算机技术） 专业型 31 电子信息工程 北京邮电大学 信息与通信工程 学术型 32 电子信息工程 清华大学 电子信息（大数据工程） 专业型 33 电子信息工程 武汉大学 电子信息 专业型 34 通信工程 哈尔滨工业大学 信息与通信工程 学术型 35 通信工程 国防科技大学 电子科学与技术 学术型 36 通信工程 上海交通大学 电子科学与技术 学术型 37 通信工程 四川大学 电子科学与技术 学术型 38 通信工程 西安电子科技大学 电子与通信工程 专业型 39 通信工程 西安交通大学 电子科学与工程 学术型 40 通信工程 西北工业大学 信息与通信工程 学术型 41 通信工程 国防科技大学 信息与通信工程 学术型 42 通信工程 电子科技大学 信息与通信工程 学术型 20级保研去向： 序号 专业 类型 推免学校 最终推免专业（全称） 专硕/学硕 1 电子信息工程 学术推免 南京大学 人工电磁材料设计与应用 直博 2 电子信息工程 学术推免 山东大学 软件工程 专硕 3 电子信息工程 学术推免 北京理工大学 智能电子信息系统 直博 4 电子信息工程 学术推免 哈尔滨工业大学 信息与通信工程 学硕 5 电子信息工程 学术推免 西北工业大学 控制科学与工程 学硕 6 电子信息工程 学术推免 西安交通大学 通信工程 专硕 7 电子信息工程 学术推免 西安交通大学 电子科学与技术 学硕 8 电子信息工程 学术推免 西安交通大学 软件工程 专硕 9 电子信息工程 学术推免 西安交通大学 信息与通信工程 学硕 10 电子信息工程 学术推免 东南大学 生物医学工程 学硕 11 电子信息工程 学术推免 天津大学 电子科学与技术 学硕 12 电子信息工程 学术推免 武汉大学 电子信息 专硕 13 电子信息工程 学术推免 东南大学 集成电路工程 专硕 14 电子信息工程 学术推免 西安交通大学 信息与通信工程 学硕 15 电子信息工程 学术推免 天津大学 信息与通信工程 学硕 16 电子信息工程 学术推免 西安交通大学 电子科学与技术 学硕 17 通信工程 学术推免 南京大学 通信与信息系统 学硕 18 通信工程 学术推免 南京大学 集成电路工程 专硕 19 通信工程 学术推免 浙江大学 计算机科学与技术 直博 20 通信工程 学术推免 电子科技大学 信息与通信工程 学硕 21 通信工程 学术推免 天津大学 电子信息 专硕 22 通信工程 学术推免 中山大学 集成电路工程 专硕 23 通信工程 学术推免 北京航空航天大学 信息与通信工程 学硕 24 通信工程 学术推免 西安交通大学 通信工程 专硕 25 通信工程 学术推免 东南大学 集成电路工程 专硕 26 通信工程 学术推免 中国科学院大学 电子信息 专硕 27 通信工程 学术推免 电子科技大学 电子科学与技术 学硕 28 通信工程 科创推免 北京理工大学 智能感知与运动控制 直博 29 通信工程 科创推免 北京理工大学 信息与通信工程 学硕 30 电子信息工程 科创推免 中国科学院大学 电子信息 专硕 31 电子信息工程 科创推免 西北工业大学 信息与通信工程 学硕 32 计算机科学与技术 学术推免 浙江大学 大数据技术与工程 专硕 33 计算机科学与技术 学术推免 浙江大学 大数据技术与工程 专硕 34 计算机科学与技术 学术推免 中国科学院大学 电子信息 专硕 35 计算机科学与技术 学术推免 东南大学 计算机技术 专硕 36 计算机科学与技术 学术推免 哈尔滨工业大学 计算机科学与技术 学硕 37 计算机科学与技术 学术推免 西安交通大学 软件工程 专硕 38 计算机科学与技术 学术推免 西安交通大学 软件工程 专硕 39 计算机科学与技术 学术推免 国防科技大学 计算机科学与技术 学硕 40 计算机科学与技术 学术推免 浙江大学 大数据科学与工程 专硕 41 计算机科学与技术 学术推免 华南理工大学 计算机技术 专硕 42 计算机科学与技术 学术推免 中国科学院大学自动化研究所 社会计算 学硕 43 计算机科学与技术 学术推免 华中科技大学 计算机技术 专硕 44 计算机科学与技术 学术推免 清华大学 软件工程 专硕 45 计算机科学与技术 学术推免 东北大学 计算机科学与技术 学硕 46 计算机科学与技术 学术推免 南京大学 软件工程 直博 47 计算机科学与技术 学术推免 北京师范大学 计算机技术 专硕 48 计算机科学与技术 学术推免 中国科学技术大学 软件工程 专硕 49 计算机科学与技术 学术推免 南方科技大学 电子信息 直博 50 物联网工程 学术推免 复旦大学 人工智能 专硕 51 物联网工程 学术推免 东北大学 计算机技术 专硕 52 物联网工程 学术推免 东北大学 ［秦皇岛］计算机技术 专硕 53 计算机科学与技术 科创推免 西安交通大学 软件工程 专硕 54 计算机科学与技术 科创推免 华中科技大学 软件工程 专硕 55 计算机科学与技术 科创推免 华中科技大学 智能科学与技术 学硕 56 计算机科学与技术 科创推免 西安交通大学 软件工程 专硕 57 计算机科学与技术 辅导员推免 东北大学 计算机技术【秦皇岛】 专硕 三、保研政策-胎教级分析（保研er必读） 学校最新文件（2024）的保研资格认定方法 五、推免申请\n满足推荐基本条件，符合下列条件之一者可申请推荐遴选：\n1、勤奋学习，刻苦钻研，成绩优秀，学习成绩GPA(总平均学分绩点)排名专业前30%。\n2、有较强的创新意识、创新能力，在五星级及以上竞赛中获一等奖及以上奖项的竞赛团队主力队员，“国家级大学生创新创业训练计划”优秀项目的核心成员，且学习成绩 GPA(总平均学分绩点)排名专业前50%。\n是不是看起来还挺容易的，这个是最最基本的要求，满足这个，只是拥有了申请保研的机会，你符合条件之后，提交了申请，接下来会给所有申请者进行排名。上面第一种称为学术推免，是学院给定每个专业多少个保研名额，按照专业排名分配。 第二种称为科创推免，由大创中心给名额，全校所有申请科创推免的同学统一进行排名。\n六、专业综合排名办法\n专业综合排名成绩=加权平均学分绩×W1+综合考核成绩×W2，加权平均学分绩和综合考核成绩满分均为100分。 其中W1=80%,W2=20%。\n（一）加权平均学分绩计算办法 （占80%）\n加权平均学分绩由学生GPA(总平均学分绩点)按以下公式计算得到：加权平均学分绩=(GPA+5)×10。\n一门课，如果你拿到95分，那么你这门课的绩点就是(95-50)/10=4.5\n如果你拿到83分，这门课的绩点就是(83-50)/10=3.3\n总平均学分绩点（GPA）就是每门课程的绩点，用该课程的学分作为权重，得到的平均值\n比如5学分的高数考了95, 2学分的英语考了83，你的GPA就是（4.5 * 5 + 3.3 * 2）/ (5 + 2) = 4.16\n实际上，最终保研的同学基本都是靠绩点排名靠前而获得保研资格的，因为GPA占了八成，所以想要保研绩点一定是最重要的。\n（二）综合考核成绩计算办法 （占20%）\n综合考核内容包括对学生的知识掌握和学术研究能力、创新能力（学科竞赛）、综合素质测评等方面的评价。综合考核成绩=知识掌握和学术研究能力×M1+创新能力×M2+综合素质测评×M3 ，其中M1=0.4，M2=0.3，M3=0.3。\n这个综合考核成绩分为三部分，他们分别代表大学中的什么东西呢\n1.知识掌握和学术研究能力 通俗的说，指的是你发表的论文或者专利。计算这项的分数时，采取代表作制，只取最高的一项，也就是说如果你发表了很多篇论文，有好几项专利，最终算保研加分时只会取其中分数最高的一项。所以与其追求数量，制造一些学术垃圾，不如追求质量，争取产出一篇高水平论文。\n正常来说，产出一篇EI会议论文是不难的，EI会议论文分值是18分，18 * M1 * W2=1.44\n把EI会议论文的加分换算成绩点呢，(1.44 / W1) / 10 = 0.18,相当于你的绩点提升了0.18，可以说非常多了，在最后保研资格的竞争中，每位同学之间的绩点差距甚至不到0.1，而发表一篇普通的EI会议，直接加了0.18的绩点。\n所以怎么拿到这部分的加分呢，之后的章节统一讲。\n2.创新能力 指的是学科竞赛，同样采取代表作制，只取分数最高的其中一项，所以还是那句话，专注做好一件事就已经足够了。\n一般来说，拿到加分的基本上是这几个比赛：\n六星级比赛的话，ACM俱乐部的icpc，ccpc，不过这个难度很大，如果高中没有接触过信息学竞赛，想要拿牌子需要付出非常非常多的精力，只适合OI选手或者对算法竞赛热爱到魔怔的同学。适合普通人的呢，比如智能车竞赛，因为基本上所有人都是零基础，努力是会有回报的，每年靠智能车得奖从而保研的人也很多，不过毕竟是六星级比赛，没有到说拿奖就拿奖的程度，此外还有全国大学生数学建模大赛，数学建模是公认的“水”，虽然拿国奖还是难，但是和xcpc，智能车这些比起来，真的可以说容易很多了。\n五星级比赛就很多了，比较大众一点的比如蓝桥杯，国际大学生数学建模竞赛，这些基本上是好好准备就能国奖的，之后会讲一下怎么大一零基础拿蓝桥杯单片机国奖。\n六星国一40分，国二15分，国三8分\n五星国一15分，国二8分，国三4分\n六星的难度太高，我们比如说冲个五星国一吧，那换算成绩点就相当于绩点+0.11，性价比也是非常高的。\n3.综合素质测评 这个包括非常多东西，比如每个学期班级同学互相打分的思评成绩，当班委的社会工作加分，参加各种活动拿到的社会实践加分等等，细分出来每一项都太小了，其实这个部分，只要你平时不要什么活动都不参加，然后和班里同学友好相处，大家的综合素质测评不会相差太多，更何况就算你年年思评垫底，然后社会工作经验为0，最后折合到保研的综合考核成绩中也只是非常非常小的差距，所以不要在这个方面上过于焦虑，做好自己该做的就好了。\n四、怎么拥有高绩点 对于需要期末考试的课，期末考试的内容一定都是上课的内容，所以，请一定好好听课，把老师布置的习题搞懂，如果有什么往年考题，一定要当宝贝一样多做几遍把题型熟悉起来。什么辅导书、考研题，应对期末考试的话是完全不需要的。如果觉得老师讲的慢或者讲的不好，可以选择网上一些老师的课程，但是一定要注意不要光看不写，做题是很有必要的，特别是老师布置的作业题，很有可能会出现在期末试卷上。\n对于马原、毛概这样的政治课，大部分是以小组任务的形式结课，想要得到好成绩的同学尽可能争取当小组的组长，主动地去承担更多的任务，有些老师的课上积极发言也会有加分。\n因为我本人是网课党，我在这里给大家可能会头疼的几门课推荐一些我当时看的网课。另外插一句，适合自己的才是最好的，以下仅供参考，还有，千万不要光看网课，然后老师布置的作业题一点不写，不会做题考试还是考不出来的。\n虽然看网课，但是上课还是要去的，不可以缺勤哦。\n【《高等数学》同济版 2024年更新|宋浩老师】https://www.bilibili.com/video/BV1Eb411u7Fw?vd_source=385c20ba07149edb29e901a7e63a6ecd\n很多人推荐宋浩老师，个人感觉宋浩老师适合基础不太好的同学，讲课进度偏慢，我当时看的是张宇老师的考研基础课，不只是高数，概率论也可以看张宇的考研基础课，简短很多也精炼很多，不过这个就需要大家自己找资源了，我是网盘看的盗版。。。\n【电路 石群老师主讲【80集全 带目录】 通俗易懂，讲得十分仔细，【适用于大学学习 考研备考】 邱关源电路第五版 电路考研】https://www.bilibili.com/video/BV1F7411a7iV?vd_source=385c20ba07149edb29e901a7e63a6ecd\n非常长的视频，但是非常仔细，不仅教你原理，也教你怎么做题，我当时学电路原理全看的石群老师，当然，自己老师上的复习课一定要去听啊，会画重点的。\n【《复变函数》基础知识全解析，适合0基础的同学快速学习】https://www.bilibili.com/video/BV1w54y1m7Wb?vd_source=385c20ba07149edb29e901a7e63a6ecd\n短小精悍，适合速成，刷完之后做做往年题可以冲击满分。\n【【4K精品】模拟电子技术基础 上交大 郑益慧主讲（模拟电路/模电 讲课水平略胜华成英，视频质量完爆清华版 4K超清重制版）】https://www.bilibili.com/video/BV1Gt411b7Zq?vd_source=385c20ba07149edb29e901a7e63a6ecd\n神中之神，学模电的同学必看。其中的深度和智慧是任何其他老师都给不了的，郑老师的课会让你对模电的理解比其他同学更深，更透彻。另加一句，这套课不会教你做题，自己要把握好。\n其他没有出现在这里的课程，要么是比较简单网上很多老师讲的都很好的，要么是网上很难找到资源需要你自己老老实实听课的，又或者是后期的一些课程你自己已经有评判一个课好不好的能力了，还是那句话，适合自己的才是最好的。\n五、关于科研和论文 ”大一小白不是什么都不会吗，也可以开始搞科研了吗？“其实只要懂高数、线代的一些概念，就完全够格了，因为是一个新的领域，换成大二、大三的来也得从头学起，况且成果的产出是需要时间的，个人觉得越早开始了解越好。\n正常来说大一下可以联系老师了。具体怎么做呢，一般来说做科研之前，至少有编程能力，有数学能力，然后在学院的官网上看各个老师的介绍，大部分都是选择本专业的老师，老师简介中会写TA正在做的科研方向，可以去知乎啊这些平台了解一下这些方向大概是做什么的，选择一个你感兴趣的老师去联系，直白一点把你的诉求告诉老师，想发论文，想做科研。老师会给你一些建议或者指导的。\n另外，联系哪个老师也是挺关键的，因为很多行政职务高的老师，虽然成果多，实力强，但是平时非常忙，几乎不会理你，能给你的指导也就非常非常少，反而是其他专注学术的相对年轻的老师，能够给你更多更精确的指导。具体哪个老师好，哪个老师不好，这是不能碰的话题。\n师傅领进门，修行靠个人。要选择科研就要做好自己摸索的准备。\n六、关于竞赛 xcpc太难没希望，数模太玄没把握，大一新生打什么比赛性价比最高？\n蓝桥杯单片机组\n这个赛道我一直都觉得是价值洼地，因为计工打这个比赛的真的很少，大家都报软件赛，去接受OIer的支配，反而是控院的同学在这个赛道捞奖。今年单片机组是计工第一次学院统一组织参赛，成绩直接超过了控院，实际上写代码本来就是计工的强项啊，特别是ACM的同学，打单片机组绝对是降维打击。\n大一轻取蓝桥杯国奖路线规划 蓝桥杯省赛在每年4月，拿到省一可以进国赛，只要是把这条线走完的同学，拿国奖不会有任何压力。\n注意这里讨论的是单片机组，软件赛还是很难的，可是两者的加分是一样的啊\n大家可以在网上了解蓝桥杯单片机组的考核形式，大概就是30分客观题（选择填空），和70分程序题（用keil软件，使用C语言代码编写一个完整程序，让51单片机实现题目要求的功能）\n需要的前置知识 C语言\n​\t别让你写代码就害怕，这个比赛甚至连结构体都用不到，找个靠谱的C语言教程，把最简单的语法熟悉起来，数组、变量、函数会定义会调用，会写循环、分支、判断语句，就足够了，需要的C语言基础就这些。大一上会学C++，学了C++你甚至都不用花时间学C了。。。不过等学校老师来教你那就太慢了，任何一个同学入学一周就能把这些东西搞懂了。\n没有了\n​\t虽然说单片机的基础是数电模电，但是说实话，对于这个比赛来说，就是写写程序操作单片机而已，考验的是你的逻辑和代码能力，完全不需要那些底层的实现原理，至少可以保证，不懂数模电对于拿国奖没有任何阻碍。\n如何准备 当你能够比较轻松地用C语言写代码解决一些简单逻辑问题之后，就可以开始正式备赛了。为什么不先学一下51单片机呢？我当时在准备蓝桥杯之前确实是先看的51单片机的教程，但是我觉得对于比赛来说，帮助真的不大，不如直接针对蓝桥杯来准备。实在是时间充裕，或者是实在对底层原理感兴趣的同学，可以看这个教程：\n【51单片机入门教程-2020版 程序全程纯手打 从零开始入门】https://www.bilibili.com/video/BV1Mb411e7re?vd_source=385c20ba07149edb29e901a7e63a6ecd\n再次强调，不了解单片机的底层原理并不影响拿国奖，而且底层原理需要数模电基础，大一同学深究这个的话很容易劝退。\n跳过底层原理，你要做的是一集一集的学完下面这个针对蓝桥杯的单片机入门视频：\n【【蓝桥杯-单片机】零基础入门省国赛冲刺培训】https://www.bilibili.com/video/BV1TR4y1k7iz?vd_source=385c20ba07149edb29e901a7e63a6ecd\n在备赛的过程中，最重要的是学习up主西风给出的模板，程序题怎么写是有一套标准的模板的，在课后任务中一次次练习，把整个框架熟悉起来。学习开发板上每一个外设怎么使用、怎么用代码来操作单片机的寄存器。很多人可能会用其他老师的模板，小蜜蜂老师、蚂蚁工厂等等，他们的模板我都看过，我相信懂的人都会觉得西风的模板更完整一些，因为正式比赛是会对单片机上每个现象的延时、数码管的刷新频率都会有要求，西风的模板是讲这些都考虑进去的，并且将这些参数全部变成程序可控的，基本上你在考场上写完代码，确认好单片机的现象没出问题就能够确定自己稳了。\n视频学完之后，找近几年的省赛国赛程序题，自己练几遍，这个非常重要，因为每年的题目变化不是特别大，考来考去就考那几个点，自己练习时候踩过的坑保证比赛时不要再踩就可以了。\n这一套流程下来，大一上结束之前肯定能搞定了，考前几个星期开始复习一下，做几套真题熟悉一下模板，基本稳稳拿下。","四怎么拥有高绩点#四、怎么拥有高绩点":""},"title":"保研相关：以电信通信为例"},"/get-started/about-cs/":{"data":{"":"","入门#入门":" 入门 声明 笔者也是个蒟蒻，就个人的粗糙经历来给学弟学妹们浅谈一下。糕手很多，欢迎热爱算法的有志之士加入NEUQ-ACM俱乐部。\n语言 语言的学习是基础的，也是最快的，初学C++可能有点门槛，但语言之间的共性会使得后续其他语言的学习更容易，所以请打开编辑器，从Hello，world开始吧！\n#incloud \u003cbits/stdc++.h using namespace std; int main(){ cout\u003c\u003c\"Hello,World!\"; return 0; } 怎么学 一切以实操为基础，你可以通过啃书，书上有很多细节和样例，但一定要理解之后自己手打一遍。\n关于入门看什么书，但从语言来说，你们的教材是谭浩强，但个人不推荐，可以试试C++ Primer和C++ Primer Plus（tb/pdd直接搜，出来的白皮封面大抵就是了，买来可别堆灰哦）\n语言的学习很快，具体的语法也是错综复杂，但在算法领域大多都用不到，不必偏执.\n算法 学算法前先学会打暴力，如果学会了打暴力，那么恭喜，你已经超过大部分人了，可以尝试在蓝桥杯中拿个省一\n怎么学 入门和学习在网上有很多资源，包括b站，csdn，博客园，acwing等等都有教学\n也有专门的算法竞赛书籍，洛谷的**《深入浅出程序设计竞赛》和清华的《算法竞赛入门经典》**等等\n基础的算法入门很快，而做题是需要人类智慧的。\n网上有很多OJ，新手建议洛谷和acwing，他们也有入门题单等等。\n刷题量差不多了，洛谷能看懂绿题和蓝题的题解，掌握了基础的算法（二分，DFS，BFS，动态规划，树状数组，线段树，并查集，二分图……）之后，就可以开始打一些网上的比赛了，牛客，洛谷，leetcode，codeforces，atcoder等平台都可以去打，在打比赛中更能锻炼自己的算法思维和码力。\n至于进阶阶段的算法学习，acwing有提高和进阶的课程，也有一个网站可以参考学习OI Wiki - OI Wiki (oi-wiki.org)\n至于拿奖，大一上除了个别OI爷有实力能直接打XCPC，暂时没有学校认定能加分的算法竞赛，不过有ACM的招新赛，欢迎大家在暑假以及开学后这段时间迅速入门C++，学会基本的暴力和解决问题的能力就能成为我们ACM俱乐部预备队的一员了。\n不过大一下有很多比赛，希望大家好好沉淀，打几个比赛把科创分加满。"},"title":"计算机类篇"},"/get-started/about-ei/":{"data":{"":"","#":"软件学习声明见前言，如做商用与科研，请请示团队\n编程软件：Keil b站：STM32入门教程-2023版 细致讲解 中文字幕_哔哩哔哩_bilibili\n在简介中，有详细的物料清单和Keil的下载与破解方式。keil对应的单片机有：51单片机\n其中51单片机涉及对寄存器操作，stm32涉及较多微机原理与模电数电，编程知识，虽然是最重要的单片机，但并不是初学者最友好的。\n优点：价格极其低廉 缺点：学习成本高昂\n编程软件：Arduino IDE 地址：Software | Arduino\n推荐新手入门uno r3,这款单片机价格便宜，可玩性强，重点是不像stm32一样涉及底层硬件知识，可以在学习C++的同时使用C语言进行编写。\n优点：价格相对低廉，学习成本相对低廉，不需要软件破解 缺点：体积相对较大\n单片机类型：micro:bit 地址：让我们开始编程吧 | micro:bit (microbit.org)\nmicro：bit最为最简单的单片机，在英国作为青少年教学单片机，在浙江作为技术选考教学单片机，使用python编程，具有代码编写简单，但是与后续的C++学习有一定的编程语言冲突\n优点：学习成本极其低廉（python非常好学） 缺点：价格极其昂贵\n电路仿真软件：Multisim 地址：Multisim–软件简介及安装教程（含Multisim14安装包资源）-CSDN博客\n由于是美国的软件，需要破解操作，安装与破解方法在上述网页\n电路仿真软件\u0026PCB绘制软件：嘉立创pro 地址：嘉立创pro\n唯一真神，免费又好用。"},"title":"电子信息类篇"},"/get-started/algorithm/":{"data":{"初识算法#初识算法":"初识算法算法（algotithm）顾名思义，就是计算的方法。 计算机和编程语言只是解决问题的工具，而算法则是解决问题的方法。\n如果要使用计算机解决某个具体问题，我们需要对计算的步骤做出相应的描述，\n进而用特定的编程语言来实现。\n对算法的研究主要是解决两个问题：“怎么算” 和 “怎样算更好”。","如何更进一步的学习#如何更进一步的学习":"以上只是对算法的一个初步介绍。算法的学习内容实际上远不止这些，\n例如搜索算法还有启发式搜索（A*）等，排序算法还有堆排序（Heap Sort），基数排序（Radix Sort）等。\n你还可以在 OI wiki 作进一步的学习。","怎样算更好#怎样算更好":"虽然具有强大的计算能力，计算机的计算能力终究是有限的，\n具体表现在计算机有着有限的计算速度和内存空间。\n在这两个因素的衡量下，同一问题的不同算法显然有优劣之分。例如，欲计算\n$$1+2+3+\\cdots+n$$\n代入求根公式 $\\dfrac{n(n+1)}{2}$ 计算显然比用循环直接计算要更优。\n“怎样算更好” 就是研究如何用尽可能少的时间和空间解决给定的问题。\n下面我们用排序，即 “将 $n$ 个数从小到大（或从大到小）排成一列” 为例，\n来具体讨论这个问题。\n插入排序 如何将 $n$ 个数从小到大排成一列？一个自然的想法是，在前 $k\\ (1\\le k\u003cn)$ 个数已经有序的情况下， 将第 $k+1$ 个数插入到这 $k$ 个数中。这就是 插入排序（Insertion Sort）。\n插入排序的 C++ 代码如下：\nvoid insertionSort(int a[],int n){//待排序的数为 a[1]~a[n]，从小到大排序 for(int k=1;k\u003cn;++k) for(int i=k;i\u003e0\u0026\u0026a[i]\u003ea[i+1];--i){ int get=a[i]; a[i]=a[i+1],a[i+1]=get; } } 如何衡量插入排序的用时呢？我们注意到，插入排序总共要进行 $n-1$ 次插入，\n第 $k$ 次插入最多发生 $k$ 次交换，因此总的交换次数最多为\n$$1+2+\\cdots+(n-1)=\\dfrac{n(n-1)}{2}$$\n算法的运行时间是一个复杂的变量，与具体的硬件和编程语言均有关。\n但是，我们并不关心实际的运行时间，而只关心运行时间随数据规模 $n$ 的增长率。\n因此，我们称插入排序的 时间复杂度 为\n$$\\Omicron(n^2)$$\n其意义是，在 $n$ 足够大时，插入排序的运行时间以二次函数的速度增长。\n类似的，可以定义一个算法的 空间复杂度。显然插入排序的空间复杂度为\n$$\\Omicron(n)$$\n归并排序 如何做到比 $\\Omicron(n^2)$ 更快呢？我们在插入排序的基础上进一步思考这个问题。\n具体地，我们不是考虑将单个数逐个插入已经排好序的数组中，而是考虑将两个已经排好序的数组合并。\n显然这是容易实现的：将两个排好序的数组分别装入两个队列中，\n每次取出两个队列的队头中较小（或较大）的那一个，其 C++ 代码如下：\nint* merge(int *a,int n,int *b,int m){ //将 a[0]~a[n-1],b[0]~b[m-1] 合并，均为从小到大排序 int *out=(int*)malloc((n+m)*4);//答案数组 int k=0,p=0,q=0;//队列的队头 while(p\u003cn\u0026\u0026q\u003cm) if(a[p]\u003cb[q]) out[k++]=a[p++]; else out[k++]=b[q++]; //两个队列均非空时，取出两个队列的队头中较小的那一个 while(p\u003cn) out[k++]=a[p++]; while(q\u003cm) out[k++]=b[q++]; //两个队列中有一个为空的情况 return out; } 显然，合并操作 merge 的时间复杂度为 $\\Omicron(n+m)$。\n只有一个数的数组一定是有序的。我们将待排序的数组分成两半，两半分别排好序后，\n即可整体合并成一个排好序的数组。这就是 归并排序（Merge Sort）。\n在我们已经实现了合并操作的基础上，其 C 代码如下：\nvoid mergeSort(int *a,int n){ if(n==1) return; int mid=n/2;//将数组分成两半 mergeSort(a,mid),mergeSort(a+mid,n-mid);//两半分别排序 int *b=merge(a,mid,a+mid,n-mid);//将两个数组合并 for(int i=0;i\u003cn;++i) a[i]=b[i]; free(b); } 归并排序的时间复杂度是多少呢？设归并排序的时间复杂度为 $T(n)$，则由排序过程得\n$$T(n)=2T\\left(\\dfrac{n}{2}\\right)+\\Omicron(n)$$\n设 $f_s=T(2^s)$，求解 $T(n)$ 等价于解递推式\n$$f_s=2f_{s-1}+2^s$$\n解得 $f_s=(f_0+s)2^s$。也就是说，归并排序的时间复杂度为\n$$\\Omicron(n\\log n)$$\n在计算机科学中 $\\log n$ 一般指以 $2$ 为底的对数 $\\log_2 n$。","怎样计算#怎样计算":"首先我们希望的是，对于任意一个突然摆在面前的问题，能给出一个可行的算法把结果算出来。\n这就是 “怎么算” 的问题。\n在确定了可能的解的范围的情况下，一个自然的想法就是搜索。搜索可以抽象为走迷宫：\n把所有可能的解（岔路口）都查一遍，从而把真正的解（出口）给找出来。\n深度优先搜索 深度优先搜索（Depth First Search，DFS） 类似于一个对迷宫一无所知的人在走迷宫时会采用的方法：\n径直走下去，如果遇到岔路口就选择一条岔路向前，\n如果走到死胡同就原路返回到之前走过的岔路口走其他岔路，\n直到走到出口或排除掉所有岔路。\n我们一般将深度优先搜索写成函数递归的形式。这样，\n函数结束后一层层回溯的过程就是返回原岔路口的过程。大致的 C++ 代码参考如下：\nvoid dfs(/* 当前状态 */){ if(/*当前为终止状态（死胡同或出口）*/){ /*更新解*/ return; } while(/*扫描所有岔路*/) if(/*岔路可以走*/){ //更新状态 dfs(/*下一状态*/);//走到下一条岔路 //撤回到原状态 } } 深度优先搜索的典型例题是 洛谷 P1706 全排列问题 。\n广度优先搜索 广度优先搜索（Breath First Search,BFS） 类似于 “水走迷宫”：\n在入口处浇水，水流遇到岔路会分成多股同时走，最终总有一股水流能到终点。\n我们用一个队列来模拟“多股水流同时移动”的过程。队列中存储的是所有待移动的水流\n（即上图的箭头），且时间戳靠前的水流在队列中也靠前。大致的 C++ 代码参考如下：\nvoid bfs(){ queue\u003ctype\u003e q; q.push(/*初始状态*/); while(!q.empty()){ type now=q.front();//取出时间戳最靠前的水流（now） q.pop(); while(/*扫描所有岔路*/) if(/*岔路可以走*/){ type nxt; /*nxt = now 的下一个状态*/ q.push(now);//下一个状态时间戳最靠后，放在队列的末尾 } } } 广度优先搜索的典型例题是 洛谷 P1141 01迷宫。"},"title":"算法入门"},"/get-started/markdown_syntax/":{"data":{"":"","#":"Markdown语法（市面上有很多编辑器，笔者这里使用的是Typora） Markdown 基本语法 | Markdown 官方教程，这里非常详细的记录了markdown常用的各种语法，本文作为介绍目标，只指出作者认为使用得多的一部分。\n创建不同级标题 ​\tmarkdown语法创建标题只需要输入#+space(空格)，一个#表示一级标题，两个#，即##，表示二级标题，以此类推，几个#就是几级标题。\n演示如下\n源代码\n# 一级标题 ## 二级标题 ## 三级标题 ","一级标题#一级标题":"","二级标题#二级标题":"三级标题 演示结束\n强调语法\n粗体 (Blod)\n要加粗文本，请在单词或短语的前后各添加两个星号**，效果如标题。\n斜体（Italic)\n要用斜体显示文本，请在单词或短语前后添加一个星号*，效果如标题。\n引用\n要创建块引用，请在段落前添加一个 `` 符号。\n演示如下\n源代码\n东北大学计算机与通信工程学院 东北大学计算机与通信工程学院\n演示结束\n创建列表\n由于篇幅限制，笔者这里只介绍了有序列表。同样，对于其他用法请参考文处给出的网页。\n要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。\n演示如下\n源代码\n1. First item 2. Second item 3. Third item 4. Fourth item First item\nSecond item\nThird item\nFourth item\n演示结束\n代码块的使用\n用三个 `，即 ```` `，输入车便可以创建代码块，这一点在大一上的代码学习中有很大作用，以下代码为笔者展示C++的第一段程序\n#include \u003ciostream int main(){ std::cout\u003c\u003c\"Welcome to Northeast University at Qinhuangdao!\"; return 0; } TIPS：\nmarkdown的分享就结束了，但是作为一款功能强大的编辑语言，更多的功能在开头的文档等你探索。\n笔者推荐的软件有：\n地址： Typora"},"title":"Markdown语法"},"/get-started/vscode/":{"data":{"vscode#VScode":"VScodeVisual Studio Code 是由微软开发的一款轻量级代码编辑器。\n下面以 VScode 配置 C++ 为例，来介绍 VScode 的安装和使用。","安装#安装":"Windows 手动安装 前往 Visual Studio Code 官网。你应该会看到和下图类似的页面：\n单击 Download for Windows 即可跳转到下载页面开始安装包的下载：\n下载完成后，双击安装包即可运行安装程序。\n在此笔者强烈建议在 选择附加任务 页面勾选以下选项：\n这样便于快速用 VScode 打开文件。\n使用包管理器 如果你有使用包管理器，可以使用包管理器来安装 VScode。\n例如，使用包管理器 winget 来安装 VScode，只需要运行以下命令:\nwinget install -e --id Microsoft.VisualStudioCode Mac 前往 Visual Studio Code 下载页面，你应该会看到与下图类似的页面：\n下载 Mac 版本后，得到的是一个 .zip 格式的压缩包，双击即可自动解压到本地目录中：\n上图红框标出的就是解压得到的应用程序。\nLinux 跳转到你的发行版的部分，按照你的发行版安装即可。\nArch Linux Arch Linux 的官方源不提供 VScode，但 AUR 有很多第三方打包的软件包。\n下面是三种使用 AUR 安装 VScode 的方式：\n使用 yay AUR helper yay -S visual-studio-code-bin 使用 paru AUR helper paru -S visual-studio-code-bin 手动安装 使用手动安装将丧失自动更新的功能。\ngit clone https://aur.archlinux.org/visual-studio-code-bin.git cd visual-studio-code-bin makepkg -si Debian/Ubuntu Ubuntu 下有两种推荐的方式进行安装：\n1. 添加 Microsoft 源并使用 apt 安装 添加 Microsoft 源：\nsudo apt-get install wget gpg wget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor \u003e packages.microsoft.gpg sudo install -D -o root -g root -m 644 packages.microsoft.gpg /etc/apt/keyrings/packages.microsoft.gpg echo \"deb [arch=amd64,arm64,armhf signed-by=/etc/apt/keyrings/packages.microsoft.gpg] https://packages.microsoft.com/repos/code stable main\" |sudo tee /etc/apt/sources.list.d/vscode.list \u003e /dev/null rm -f packages.microsoft.gpg 安装 VScode：\nsudo apt install apt-transport-https sudo apt update sudo apt install code # or code-insiders 2. 手动下载并安装 前往 Visual Studio Code 下载页面，下载 .deb 格式的软件包，\n然后双击软件包即可自动打开软件包管理器进行安装，或使用命令：\nsudo dpkg -i code_*.deb 使用手动安装将丧失自动更新的功能。\n关于 snap 千万不要使用 snap，snap有严重的性能问题，而且会导致一些奇怪的问题。\nFedora sudo dnf install code openSUSE 参考 openSUSE 官方文档。需要注意的是，如果使用手动安装的方式，则丧失了自动更新的功能。","安装插件#安装插件":"第一次打开 VScode，映入眼帘的应该是与下图类似的页面：\n此时 vscode 的语言为英语。为了切换语言为中文，点击左侧的 ，进入插件商店：\n在搜索框中搜索 chinese，搜索结果的第一个就是 vscode 的简体中文插件：\n单击 Install 即可安装中文插件，进而切换语言为简体中文。\n到此你应该已经学会了给 vscode 安装插件了。\n插件是 vscode 的核心之一。同样地，若要给 vscode 配置相关的编程语言，我们也往往需要安装相应的插件。\n例如，若要配置 c++，我们需要安装微软的 C/C++ 插件（下图第一个）\n或者 C/C++ Extension Pack 插件包（下图第三个）：","安装编译器#安装编译器":"由 C++、Python 这样的高级语言编写的代码是不能被计算机直接执行的，\n这是因为计算机只认识由 0 和 1 表示的二进制机器指令。\n如果要执行它们，要采取以下两种方式中的一种：\n将高级语言编写的代码整体翻译成机器指令，即 编译（如 C++）。 将高级语言逐句翻译为机器指令，即 解释（如 Python）。 vscode 只是一个代码编辑器，它不具备编译或解释高级语言代码的功能。\n为了编译 C++ 代码，我们需要额外安装编译器。\nLinux linux 系统下，最常用的 C/C++ 编译器毫无疑问是 GCC（GNU 编译器套件，GNU Complier Collection），\n此处我们安装的是套件里的 C++ 编译器 g++。\n跳转到你的发行版的部分，按照你的发行版安装即可。\nArch Linux # 安装相关的编译工具 sudo pacman -S base-devel Debian/Ubuntu # 安装相关的编译工具 sudo apt install build-essential Fedora sudo dnf install gcc sudo dnf install gcc-c++ openSUSE sudo zypper install gcc sudo zypper install gcc-c++ Mac macOS 已经自带了苹果的 C/C++ 编译器 clang，且命令 g++ 被重定向到了 clang++，\n二者的命令参数大多是共享的。你可以像在 linux 下使用 GCC 一样使用 clang。\nWindows 和 linux 一样，Windows 下也是可以使用 GCC 编译器的。但与 linux 下不同的是，\n它被集成到了 MinGW（Minimalist GNU for Windows）中。\n原版 MinGW 只支持在 32 位系统中生成 32 位程序。\n此处我们要安装的是 MinGW 的 64 位扩展版本 MinGW-w64，其同时支持 32 位和 64 位系统。\n打开 MinGW-w64 官网 的 下载页面，如下图所示：\n解压下载下来的压缩包后，将解压得到的文件夹放到一个合适的位置，\n然后打开里面的子文件夹 bin，就能找到 g++.exe：\n你可以直接在命令行下使用 g++.exe 完成编译。但为了适配 vscode，我们还需要配置环境变量。\n右击 此电脑，单击 属性，然后点击 高级系统设置，再点击 环境变量：\n双击系统变量 Path，然后把 MinGW-w64 的 bin 文件夹的路径加进去：\n确定加进去后，进入命令提示符，输入 g++ 并回车，此时系统会根据环境变量直接调用 g++.exe，\n你应该会看到以下输出：\n这表示编译器和环境变量配置成功。","尝试用-vscode-编写-c-程序#尝试用 VScode 编写 C++ 程序":"现在是时候尝试用 VScode 编写 C++ 程序了。新建 a.cpp 并打开，输入以下代码：\n#include\u003ciostream\u003e using namespace std; int main(){ cout\u003c\u003c\"Hello World!\"\u003c\u003cendl; return 0; } 在右上角选择 “运行 C/C++ 文件”，再在弹出的页面选择你配置好的编译器：\n第一次运行会先跳到终端然后跳到调试控制台，我们转回终端，就能看到程序的输出：\nGithub链接与使用\n数学建模相关\nb站：数学建模老哥\nb站：清风数学建模\n以上两个是b站名气最高的数学建模讲解，如有需要软件，这些视频简介中都有获取方式"},"title":"使用 Visual Studio Code"},"/loongson/":{"data":{"2024-获奖经历#2024 获奖经历":" 龙芯杯团队赛全国二等奖×2（团队各有大一成员一名） 操作系统全国三等奖（团队两位大一成员） 诚挚欢迎每一位对计算机底层感兴趣的同学，龙芯班欢迎各位到来，希望能与你共建东秦龙芯生态。","什么是-cpu操作系统又是什么#什么是 CPU？操作系统又是什么？":"什么是 CPU？操作系统又是什么？龙芯班是计工优秀科创团队之一，与龙芯中科联合达成合作，专注计算机底层。从 CPU 到操作系统，用 Verilog 书写属于自己的处理器，用 Rust/C 编写独属于自己的 OS。","快加入招新群#快加入招新群！":"点击此链接，或扫码下面的二维码，立刻加入2024龙芯实验室交流群！","来龙芯能学到什么#来龙芯能学到什么":" CPU 设计方法：可独立设计一款五级流水线处理器（熟练可冲击六级流水线），掌握 CPU 基本设计思路，了解国内处理器企业，获得龙芯中科实习经历。\nOS 架构设计：用 Rust/C 编写属于自己的 OS，掌握操作系统架构，独立编写 OS 中几个功能模块，学会上板烧录进行命令行互动，了解系统调用背后的故事。\n编译器设计：设计一款支持类 C 语言的编译器并进行性能优化，深入学习编译原理，指令优化以及编程语言设计。","能参加什么竞赛#能参加什么竞赛":"龙芯班于每年暑假参加全国大学生计算机系统能力竞赛下属的龙芯杯与操作系统大赛。（同属于为五星级竞赛🌟🌟🌟）"},"title":"龙芯实验室招新"},"/use-git/":{"data":{"":" 1. 初识 Git 2. 安装 Git 3. 配置 Git 命令行 4. 认识命令行 5. Git 入门 6. 开始使用 GitHub 7. 冲突 8. 养成良好的 Git 使用习惯 "},"title":"Git 及 GitHub 使用指南"},"/use-git/best-practice/":{"data":{"":"本文将介绍一些 Git 的最佳实践，帮助你更好地使用 Git。","commit-时机#Commit 时机":"很多新手在使用 Git 时，要么提交太多次。这样会让你的提交历史变得混乱，也会让你的团队很难理解你的提交。要么提交太少，这样会让你的提交历史变得不够详细，也会让你的团队很难理解你的提交。\n一个好的提交时机是在你完成一个功能后提交。这样可以让你的提交历史更加清晰，也更容易回滚。\n要理解，commit 的本质是patch，当你的 commit 较为复杂时，就不容易patch apply。所以，尽量保持 commit 的简单，但是简单的前提是保证一项功能的完整性。","git-使用最佳实践#Git 使用最佳实践":"注：以下内容翻译自Git Best Practices – How to Write Meaningful Commits, Effective Pull Requests, and Code Reviews\n作者： Grant Riordan\n编写有意义的提交信息 在提交代码时，编写有用的提交信息是很有帮助的。以下是一些提示和最佳实践，帮助你做到这一点。\n使用祈使句 在提交信息前缀中使用祈使句，例如：fix、refactor、add 和 remove。\n这应该是你提交信息的第一个单词，因为它可以很容易地告诉你的同事这个提交的目的：\n“If applied, this code will…” 并告知其他开发人员它将做什么，例如：\nIf applied, this code will fix issue with login button not showing 保持简洁 你不是在写独白，所以保持简洁。一般来说，提交信息不应超过 50 个字符。\n站在开发人员或审查者的角度思考。如果你在查看这个仓库的 Git 日志时，你会想知道什么？\n你完成了什么工作？ 你为什么这样做？ 它对代码库有什么影响？ 以下是一个简洁但信息丰富的提交信息示例：\nfix issue with login button not showing 保持简洁但是有意义 在你的提交中，你可以包含提交描述，允许我们添加更多的细节/上下文说明你做了什么。\n在提交信息下方添加一个空行，并在第 3 行开始编写描述。它看起来像这样：\nfix issue with login buttton not showing - update login form validation - update login styling for showing the button 现在，当其他开发人员查看提交历史，或回滚代码时，他们会更清楚地了解会发生什么，以及是否会产生任何副作用。\n反面教材 fixed bug – 没有提到具体修复了什么 bug，因此它对 git 历史/日志没有任何价值。这将使审查以前的提交变得极其困难和痛苦。作为开发人员，你必须打开每个这样的提交才能理解它实际上在做什么。\nrefactored due to PR comments – 此信息没有提供有关更改的任何信息。我们必须追踪 Pull Request 以收集有关所做更改的任何上下文，或者再次打开提交。\nfixing previous commit – 同样，缺乏上下文\nmade tests pass – 更新了哪个测试文件？你至少应该提供已修复的测试名称或区域。 所有这些都是不良提交信息的示例，因为它们含糊不清、缺乏信息和上下文。它们迫使团队成员做更多的工作来理解发生了什么，这是任何团队都不能接受的。\n如何制定提交策略 你可能认为提交代码就是简单地提交和推送代码。但实际上，这里面还有一些细微的差别。\n让我们来谈谈如何制定一个有用的提交策略，以保持一致性并做出有价值的提交。\n进行小而具体的提交 小规模的提交使得在出现问题时，能够更容易地将代码恢复到之前的状态。如果你的提交影响了太多的区域，那么回退可能意味着丢失大量的代码。\n对于代码审查者来说，如果提交只与一个特定的目的相关，他们会更容易理解代码的作用。\n让我们来看一个实际的例子，看看这是如何运作的。首先，我们需要添加相关的文件更改。我们可以通过运行 git status 来查看当前分支中哪些文件已被更改。\nOn branch: master No commits yet Untracked files: (use \"git add \u003cfile\u003e...\" to include in what will be committed) .DS_Store login.test.ts login.ts product.ts registeration.test.ts registeration.ts validation.test.ts validation.ts no changes added to commit (use \"git add\" and/or \"git commit -a\") 如你所见，有多个文件已在项目中被更改或添加。然而，这些文件分别属于项目的不同部分。遵循保持提交小而相关的黄金法则，让我们看看如何将其付诸实践。\n我们可以使用 git add 命令加上文件名，仅提交那些相关的文件。具体操作是使用 git add 命令，然后逐一添加我们希望提交的文件名，例如：\ngit add login.test.ts login.ts 如果我们现在检查 git status，就会看到这两个已暂存的文件：\nChanges to be committed: (use \"git rm --cached \u003cfile\u003e...\" to unstage) new file: login.test.ts new file: login.ts 我们已经暂存了这些文件，现在要创建提交。一如既往，我们将使用 git commit，这会在 VS Code 中打开 git 编辑器（因为我们之前已经这样设置过）。如果你跳过了这一步，提交信息会在你首选的编辑器中打开。\n接下来，我们添加一个描述更改的提交消息：\nFix issue with login button not showing 这样就完成了一个小而相关的文件提交。提交消息明确地告诉我们进行了什么更改、问题出在哪里，并提供了一些关于问题的小背景信息。\n反面教材 不良提交示例\n既然我们已经成功完成了一个良好的提交，让我们来看看一个不良提交的例子：\n假设我们已经完成了所有工作，开发者使用 git add -A 命令一次性暂存了所有更改或添加的文件。\n多个不相关文件被暂存以提交的示例\nChanges to be committed: (use \"git restore --staged \u003cfile\u003e...\" to unstage) new file: .DS_Store new file: product.ts new file: registeration.test.ts new file: registeration.ts new file: validation.test.ts new file: validation.ts 然后，他们使用一行命令创建了提交消息：\ngit commit -m 'Updated various areas such as validation, registration and products pages' 为什么这是一个糟糕的提交？ 首先，这个提交包含了太多更改。过多的文件意味着如果我们需要回退验证部分的更改时，将无法只回退那一部分。我们不得不回退整个提交，从而丢失产品和注册部分的更改。\n其次，提交消息过于冗长。我们可以去掉诸如“various areas such as”这样的无意义的词语。这些词语对提交消息没有任何贡献，还占用了本可以用于更多背景信息的字符数。\n此外，我们没有使用前面提到的祈使语态。我们应该将“Updated”改为“Update”。\n如何创建高效的 Pull Requests 决定何时推送 推送是将你的提交发送到服务器/远程仓库，以准备创建 Pull Request （PR）的过程。我建议在当前功能或修复完成后立即进行推送。\n此外，保持你的 PR 小而精简，仅包含相关的提交是个好主意。例如，如果你有以下提交：\n添加新产品搜索组件 为产品搜索组件添加单元测试 添加产品搜索组件的文档 由于所有这些提交都与同一组件相关，建议将它们合并到一个 PR 中。\n而像这样的提交：\n修复登录屏幕中的错误 为提高性能重构注册页面 更新登录表单的验证测试 更新登录测试以支持忘记密码功能 更新产品搜索组件的单元测试 不应放在同一个 PR 中，因为这些提交涉及太多不同的内容。这些提交应该根据相关性分组为多个 PR。\n如果这是一个分支的 Git 日志，你将无法仅使用相关文件创建 Pull Request ，因为提交的顺序已经固定，你不能简单地告诉 Git 你希望将第 1、3 和 4 个提交放入这个 PR 中。\n保持小规模 记住——就像你的提交一样，保持 PR 小而精简。没有人愿意处理一个包含 50 多个文件的 Pull Request 。这样做只会让你的审查陷入常见的“看起来没问题”的陷阱。\n当你创建一个大型 PR 时，实际上是在传达“我不想仔细检查所有这些文件，但粗略看了一下，好像还行”的信息。相比之下，一个小型 PR 则更容易得到确切的审查意见。\n有时，大型 Pull Request 是不可避免的，比如在更新基础功能时。然而，你应该尽量考虑如何减少对其他开发人员的影响。\n如何为代码审查做好分支准备 创建 Pull Request 的具体流程会因所使用的版本控制托管平台而有所不同，但基本概念是相同的。\n首先，你应该从代码库中检出主分支（通常是 main 或 master）。然后运行 git pull，这会将主分支的最新代码拉取到你的本地开发系统中。\n完成后，你可以使用 git checkout 命令切换回你自己的分支，例如：\ngit checkout login-fixes 现在，我们需要将主分支的代码合并到你的分支中。可以使用 git merge 命令来实现这一点：\ngit merge main 如果存在更改，即从主分支拉取的文件中有更新，你需要创建一个“合并提交”。这是在你的分支上包含合并更改的另一个提交。\n只需创建另一个提交，并附上解释你已经从主分支合并的消息，例如：\ngit commit -m 'Merge main into login-fixes' 最后，使用 git push 将你的更改推送回远程服务器。\nPR 代码审查 审查 PR 时需要注意什么 在审查 PR 时，首先要退一步，考虑良好代码审查的关键要素。以下是一些需要考虑的要点：\n代码是否遵循团队的编码规范？ 确保提交的代码符合团队的编码标准和惯例。这是维护代码库一致性的重要步骤。\n代码是否达到了预期目标/验收标准？ 审查代码是否实现了它所承诺的功能或修复了特定的问题，并符合相关的验收标准。\n代码是否易读易懂？ 代码是否易于理解，而无需大量注释或文档？这点非常重要，尤其是当函数和变量名称具有描述性时，可以大大提高代码的可读性。\n代码是否需要重构？ 从安全性、性能或可读性角度考虑，代码是否需要重构？通过重构，代码可以变得更简洁、更高效。\n代码是否遵循简单的设计模式/原则？ 例如单一职责原则、抽象、封装等。如果没有遵循，可以提出建议，或者向不熟悉这些概念的开发者解释其含义及其带来的好处。\n是否存在“magic 数字/字符串”？ 检查代码中是否有未命名的常量或字符串，考虑将其替换为命名常量或变量，以提高代码的可维护性。\n及时审查 PR 虽然不必马上查看 PR，但也不要让作者久等。这个 PR 可能会阻碍后续工作，或者它可能很重要（如果是这样，作者应该明确说明）。\n尽量保持讨论和 PR 评论的顺畅。如果方便的话，可以通过电话（如果是远程工作）或在办公室里一起审查 PR，这可能会加快流程，减少来回等待的时间。\n尽管如此，也不要急于完成代码审查。要仔细、认真地阅读每个文件和更改。我建议你检出包含更改的分支，查看整个项目，而不仅仅是更改的几行代码。\n很多时候，仅仅查看一两行代码的更改，你可能无法准确理解代码的意图。但如果查看整个文件，你可以更好地理解代码的整体逻辑。\n如果你使用的是 VS Code 和 GitHub，可以利用它们的扩展功能，在 VS Code 内部查看 PR、发表评论，并同时检出 PR 分支。\n记住我们都是人 记住，我们都是人，编写代码时人们经常会犯错误，也可能忽略一些细节。\n并不是每个人的编码方式都和你一样，所以不要仅仅因为别人的做法和你的不同就要求修改。这并不意味着他们做错了，也不意味着你的方式就是最好的。\n清晰描述修改意见，谨慎措辞 拉取请求（PR）不是考试，也不是你严厉批评别人工作的机会。这是一个学习的机会，也是确保最佳代码进入主分支的机会。重点在于代码质量以及代码是否符合验收标准。\n在提出建议时，考虑一下你使用的语言。PR 评论与 git 提交消息恰恰相反。在 PR 评论中，我们不再使用祈使语态。不要命令对方做出更改，而是使用虚拟语气来提出更柔和的建议。\n由于你是在批评别人可能付出了很多努力的工作，使用一些委婉的表达方式，比如：\n“如果是我，我会将这个 if 语句改为 switch case 语句，因为它更易读。” “或许可以考虑将这个变量重命名为一个更直观的名称，例如 {alternative}，这样可以更容易理解它的作用。” 如上所述，尝试添加你提出修改建议的原因。这样会使建议更有影响力，并让作者思考是否应该做出更改，或者引发讨论以达成折中方案。\n提供改进建议 大多数 Git 系统允许你点击需要更改的代码行并添加评论，这样更容易指定你希望修改的确切代码行。\n像 GitHub 这样的托管平台有“建议”功能，允许你在评论中直接添加代码建议，这些建议可以在 PR 中立即接受并提交。\n如果没有这个功能，确保你请求的内容清晰简明。你甚至可以在评论中重写或写出你的建议，例如：\n“或许可以考虑将这个 if/else 语句改为三元表达式，如下所示：”\nvar backgroundColor = isError ? 'red' : 'blue' 这样可以使建议更加明确，并加快重新编写的过程（通过复制粘贴）。\n不要害怕为你的代码辩护 记住，PR 是一种讨论。这是一个双向的过程，给你机会为你的代码辩护，并用更多的背景信息解释你的想法。\n尽管代码可能看起来不完美，但可能有原因。可能存在你无法控制的因素，迫使你以某种方式编写代码。\n不要害怕提出反驳意见，但要准备好合理的理由，尤其是在你确实相信你的解决方案是最佳的情况下。\n传达 PR 已被批准 如今，许多人会将 GitHub 或其他版本控制系统的电子邮件通知过滤到一个文件夹里，由于仓库、提交、分支等的更新量太大，通常很少查看这些通知。\n为了加快进程，并使作者的体验更愉快，可以简单地给他们发个消息。许多公司现在都有即时消息服务，为什么不利用这一点呢？","代码审查#代码审查":"代码审查是一个非常重要的环节。代码审查可以让你的代码更加稳定，也可以让你的团队更好地了解你的代码。在代码审查时，你应该遵循以下原则：\n代码审查应该在开发完成后进行。 代码审查应该在一个独立的分支上进行。 代码审查应该由其他人进行，这样可以更好地发现问题。最好是一群擅长不同领域的人进行代码审查。 ","分支管理#分支管理":"分支是 Git 中最重要的概念之一。分支可以让你在不影响主分支的情况下进行开发。在开发时，你应该遵循以下原则：\n主分支是稳定的，不应该直接在主分支上进行开发。 每个功能应该在一个独立的分支上进行开发，这样可以更好地管理代码。 开发完成后，应该将分支合并到主分支上。 这是我在前面的教程中一定要求大家在语义分支上进行开发的原因。这样可以更好地管理代码，也更容易回滚。","合并分支#合并分支":"通常来说，在本地合并分支时，应该使用 rebase 来合并分支。这样可以让你的提交历史更加清晰，避免出现不必要的合并提交。\n在 Pull Request 合并时，应该使用merge来合并分支。这样可以让你的提交历史更加清晰，也更容易回滚。","提交信息#提交信息":"提交信息是 Git 中最重要的一环。一个好的提交信息可以让你的团队更好地了解你的提交。一个好的提交信息应该包含以下内容：\n提交的目的 提交的内容 提交的原因 虽然包含的内容还挺多，但是请尽量控制在 50 个字符以内。这样可以让你的提交信息更加简洁，也更容易阅读。 如果一定要添加更多的解释，请用足够简短的语言来解释，然后换行，用更详细的语言来解释。"},"title":"养成良好的 Git 使用习惯"},"/use-git/configure/":{"data":{"":"","配置-git#配置 Git":"首先按照上节课教你的方法打开终端或者 Git Bash。确保你能够从终端访问到git后，把这个窗口放在一边。\n我们需要配置一些基本信息，包括：\n你的名字，一般是真实姓名，使用英文 你的邮箱，如果要使用 GitHub，这个邮箱必须和你的 GitHub 账号绑定 SSH 密钥 让我们先从简单的来，配置你的名字和邮箱。\n配置名字和邮箱 配置名字 在命令行中输入以下命令：\ngit config --global user.name \"\u003c你的名字\u003e\" 姓名一定要用双引号括起来，否则空格后的内容会被忽略。\n例子：\ngit config --global user.name \"Caiyi Shyu\" 配置邮箱 在命令行中输入以下命令：\ngit config --global user.email \"\u003c你的邮箱\u003e\" 例子：\ngit config --global user.email \"cai1hsu@outlook.com\" 如果不小心输错了，可以再次输入命令进行更改。配置完成后，可以通过以下命令查看配置是否成功：\ngit config --global user.name git config --global user.email 在我的机器上，输出如下：\ncaiyi@archlinux ~\u003e git config --global user.name Caiyi Shyu caiyi@archlinux ~\u003e git config --global user.email cai1hsu@outlook.com 你的输出应该和你输入的一样。\n我们在配置的时候都添加了--global选项，这意味着你在这台电脑上的所有仓库都会使用这个名字和邮箱。\n在提交记录中，这个名字和邮箱会被记录下来，所以请确保你的名字和邮箱是正确的。\n例如，在一个git仓库中，使用git log可以查看提交记录，其中有一个字段是Author，这个字段就是你的名字和邮箱。\n例子：\nAuthor: Caiyi Shyu \u003ccai1hsu@outlook.com\u003e Date: Wed Jul 31 16:54:32 2024 +0800 fix click to expand on touch devices commit 77d64e0c3d593d4b912a6fc8d2f1e16a9e46e9b8 配置 SSH 密钥 当你访问在远程的仓库时，你需要凭证来证明你具有访问权限。在以前，代码托管平台允许你使用用户名和密码来访问仓库。但是现在，这种方式已经被淘汰了，因为它不够安全。\nSSH 使用非对称加密来保护你的数据。在这种加密方式中，有两个密钥：公钥和私钥。公钥是公开的，任何人都可以看到。私钥是私有的，只有你自己知道。使用一种密钥加密，则必须使用相配对的另一种密钥解密。除此之外，密钥无法被暴力破解，因为它的长度太长了。\nSSH 密钥有不同算法，常用的有 RSA 和 ED25519。任选一种即可。\n生成 SSH 密钥需要邮箱，请务必使用和上面一样的邮箱。\n回到终端，输入以下命令：\nssh-keygen -t \u003c算法\u003e -C \"\u003c邮箱\u003e\" 例子:\nRAS 算法 ssh-keygen -t rsa -b 4096 -C \"cai1hsu@outlook.com\" ED25519 算法 ssh-keygen -t ed25519 -C \"cai1hsu@outlook.com\" 注意！请不要复制我的例子，把例子中的邮箱替换成你的邮箱。\n输入命令后，直接一路回车，直到你看到和以下内容相似的完整的输出：\nGenerating public/private ed25519 key pair. Enter file in which to save the key (/home/codespace/.ssh/id_ed25519): Created directory '/home/codespace/.ssh'. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/codespace/.ssh/id_ed25519 Your public key has been saved in /home/codespace/.ssh/id_ed25519.pub The key fingerprint is: SHA256:5SUADhuC/DSS66Zrzyj1Jqn6FMiQPv3ZAJUAYgjK940 your_email@example.com The key's randomart image is: +--[ED25519 256]--+ |*++.+.o.. | |B= +.* . | |+.=oo . o . | |+oo.o o o o | |o+.. E .S . | | oo.. + | |o..o o . | |oo= o | |B=o= | +----[SHA256]-----+ 看到这个输出，说明你的 SSH 密钥已经生成成功了。请务必注意这个页面的输出不能分享给任何人。\n不过你目前仍然不能通过 SSH 访问远程仓库，因为你的公钥还没有添加到远程仓库。在后面讲解GitHub工作流的章节中，我们会讲解如何添加公钥到远程仓库。\n补充：配置编辑器 如果上一讲中你不是在windows平台下手动安装的git，默认编辑器应该是vim。对于大多数新手来说，vim是一个很难上手的编辑器。因此，我们可以将默认编辑器更改为其他编辑器。\n更改为VSCode 在命令行中输入以下命令：\ngit config --global core.editor \"code --wait\" 这个命令会将默认编辑器更改为VSCode。--wait选项是告诉git等待编辑器关闭后再继续执行。\n如果你没有安装VSCode，也没有其他合适的编辑器，可以使用nano。nano是一个简单的命令行编辑器，使用起来比vim简单。并且，使用nano的方式都写在了屏幕下方，你不需要查看教程就能使用。\n更改为nano 在命令行中输入以下命令：\ngit config --global core.editor \"nano\" 接下来，我们来学习一下命令行的基本操作。"},"title":"配置 Git 命令行"},"/use-git/conflict/":{"data":{"":"冲突是使用 Git 的过程中不可避免的问题。冲突的产生是因为两个人同时修改了同一个文件的同一部分。Git 无法判断哪个修改是正确的，因此需要人工介入。","冲突的产生和解决#冲突的产生和解决":"冲突的产生是因为两个人同时修改了同一个文件的同一部分。例如，Alice 修改了文件的第一行，Bob 修改了文件的第一行。当 Alice 将修改推送到远程仓库时，Git 会提示 Bob 有冲突，Bob 需要解决冲突后再推送。\n下面让我们来产生一个冲突。\n请完整克隆这个仓库这个仓库的所有分支。你可以使用以下命令：\ngit clone https://github.com/NEUQ-CS/solve-conflict.git 进入仓库后，打开README.md查看，又是1加到100的作业。\n// 下面是一段计算1到100的和的代码。 int sum_1_to_100(void) { int sum = 0; for (int i = 1; i \u003c= 100; i++) { sum += i; } return sum; } 你觉得这个代码太弱智了，于是你决定使用高斯公式来修改这份作业。\n首先我们检出一个新的分支gauss-formula。\ngit checkout -b gauss-formula 但是先别立即开始修改代码，让我们模拟一下冲突的产生。\n假设 Alice 也在修改这份作业，她有另一种方法来优化这段代码。现在假设你是 Alice，让我们先回到主分支。然后切换到alice-fix。输入git log查看一下提交记录。\n发现 Alice 提交了一个修改，在编译期间计算出了1到100的和。现在让Alice把这个修改合并到主分支。\ngit checkout master git merge alice-fix 好的，Alice 的角色扮演结束了，现在回到你的角色。\ngit checkout gauss-formula 然后修改代码：\n// 下面是一段计算1到100的和的代码。 int sum_1_to_100(void) { const int begin = 1; const int end = 100; return (end * (end + begin)) / 2; } 然后提交代码。\ngit add README.md git commit -m \"use gauss formula to calculate sum from 1 to 100\" 现在尝试合并到主分支。\ngit checkout master git merge gauss-formula Boom! 冲突产生了。你应该会看到以下结果：\ncaiyi@archlinux ~/r/solve-conflict-bak (master)\u003e git merge gauss-formular Auto-merging README.md CONFLICT (content): Merge conflict in README.md Automatic merge failed; fix conflicts and then commit the result. 让我们用git status查看一下：\ncaiyi@archlinux ~/r/solve-conflict-bak (master|MERGING)\u003e git status On branch master You have unmerged paths. (fix conflicts and run \"git commit\") (use \"git merge --abort\" to abort the merge) Unmerged paths: (use \"git add \u003cfile\u003e...\" to mark resolution) both modified: README.md no changes added to commit (use \"git add\" and/or \"git commit -a\") git 命令行提示，两者都修改了README.md。但是同时修改同一个文件并不一定意味着一定会有冲突。如果两者修改的部分不同，Git 会自动合并。但是如果两者修改的部分相同，就会产生冲突。\n再次打开README.md，你会发现这个文件变成了你完全不认识的样子：\n我这里不得不用图片，因为这些内容也会被当前的仓库当成冲突处理。\n由一堆\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c和一堆\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e包裹的部分就是冲突的部分。=======后的部分是你的修改(后出现的修改)，`前面的是别人的修改(先出现的修改)。这些符合叫做合并冲突标记。\n你需要手动解决冲突。解决冲突意味着你要删除合并冲突标记，并保留一个你认为正确的修改。\n在你看来，硬编码了int sum = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 + 31 + 32 + 33 + 34 + 35 + 36 + 37 + 38 + 39 + 40 + 41 + 42 + 43 + 44 + 45 + 46 + 47 + 48 + 49 + 50 + 51 + 52 + 53 + 54 + 55 + 56 + 57 + 58 + 59 + 60 + 61 + 62 + 63 + 64 + 65 + 66 + 67 + 68 + 69 + 70 + 71 + 72 + 73 + 74 + 75 + 76 + 77 + 78 + 79 + 80 + 81 + 82 + 83 + 84 + 85 + 86 + 87 + 88 + 89 + 90 + 91 + 92 + 93 + 94 + 95 + 96 + 97 + 98 + 99 + 100;显然是一个对可读性非常不友好的修改。因此你决定保留高斯公式的修改。\n让我们删除冲突标记，alice 的代码以及上面那句话。修改完后保存文件。\n这个文件现在应该看起来和你原来作出的修改一样。\n然后将修改加入暂存区。\ngit add README.md 然后提交。解决完冲突并提交的时候不需要手动输入提交信息。因为你原本是想合并两个分支的修改，因此commit就是一个合并提交。我们可以直接输入\ngit commit 接下来你应该会来到一个编辑器界面，这个界面显示了合并提交的信息。这个信息包含了两个分支的提交信息，你可以保留这个信息，也可以修改这个信息。这个信息的格式是这样的：\nMerge branch 'gauss-formular' 下面还有一堆信息，不过它们都是注释，不会被提交。\n保存并退出编辑器，然后你就完成了合并。\n[master fb2755b] Merge branch 'gauss-formular' 现在你可以推送到远程仓库了。"},"title":"冲突"},"/use-git/get-started-with-gh/":{"data":{"":"要使用 GitHub 托管你的代码，你需要一个 GitHub 账号。这部分不再赘述，你可以自行注册。本文假设你已经注册了 GitHub 账号。\nGitHub 以 Git 为基础，它本质上托管了一个个 Git 仓库。为了能够用 Git 访问 GitHub 上的仓库，你需要配置 SSH 密钥。在前面的教程中，我们已经为自己生成了 SSH 密钥，现在我们要将这个密钥添加到 GitHub 上。","github-工作流#GitHub 工作流":"关于拉取，推送远程仓库的操作，我们在使用 Git中已经讲过，这里不再赘述。将你的代码推送并保存在 GitHub 上，就是使用 GitHub 托管代码。\n这里我们要讲的是如何使用 GitHub 进行协同开发，以及对其他项目作出的贡献。\n使用 GitHub 进行协同开发，主要分为以下步骤：\n克隆远程仓库 检出到语义分支 编写代码 提交并推送语义分支到远程仓库 发起 Pull Request 仓库维护者审查代码 根据反馈修改代码(Optional) 合并 Pull Request Pull Request Pull Request 是你请求将一个分支合并到另一个分支的操作。在 GitHub 上，Pull Request 通常用于请求将你的代码合并到主分支。在这个过程中，仓库的维护者会对你的代码进行审查（review），提出修改意见，最终决定是否合并。\n在开启 Pull Request 的过程中，继续对代码进行修改是很常见的。你可以在提交 PR 的分支中继续提交代码，这样审查者就可以看到你的修改。审查者也可以在 Pull Request 中提出修改意见，你可以根据意见进行修改。\n发起 Pull Request 可以在同一个仓库间发起，也可以在 Forks 间发起，Fork和源仓库间发起。稍后我会介绍 Fork。\nFork 上述的协同开发的步骤适用于你具有直接读写权限的仓库，即你自己的仓库或者你所在组织的仓库。\n对于你不直接具有写入权限的仓库，你需要 Fork 这个仓库。Fork 是 GitHub 提供的一个功能，它可以将一个仓库复制到你的账号下，你可以对这个仓库进行任意操作，包括修改，删除等。\nFork 一个仓库后，你可以在你的 Fork 中创建分支，修改代码，提交代码，发起 Pull Request。Fork 仓库的 Pull Request 可以发到源仓库中，当源仓库的维护者接受你的 Pull Request 后，你的代码就会合并到源仓库中。\n使用 GitHub 对其他项目作出贡献的步骤基本于上述步骤相同，只是你需要 Fork 这个仓库，然后在 Fork 中进行操作，步骤如下：\nFork 仓库 克隆 Fork 仓库到本地 检出到语义分支 编写代码 提交并推送语义分支到 Fork 仓库 发起 Pull Request 仓库维护者审查代码 根据反馈修改代码(Optional) 合并 Pull Request ","github-相关操作#GitHub 相关操作":"上述对 Pull Request 和 Fork 简单介绍，希望你能够理解这两个概念，下面让我们来实际操作一下。\n假设我们要对本手册的仓库作出贡献，请先来到本仓库主页https://github.com/NEUQ-CS/manual。\n点击右上角的Fork，来到 fork 界面。\n请务必确保取消勾选Copy the master branch only，然后点击Create fork。\n等待操作完成后，你就来到了你的 Fork 仓库。\n现在，把这个仓库检出到本地：\ngit clone https://github.com/\u003c你的用户名\u003e/manual.git 然后进入本地仓库。\n接着，请一定创建一个语义分支，不要在master分支上进行修改。语义分支意味着这个分支上的更改有一个明确的目的，比如fix-typo，add-new-section等。我现在在为本仓库编写使用 Git 的教程，所以我创建了一个git-tutorial分支。\ngit checkout -b git-tutorial 接着，我们在src目录下编写一个新的教程，比如use-github.md。\n编写完成后，用前面教你的方法commit，然后推送到你的 Fork 仓库。\n# 添加更改到暂存区 git add src/use-github.md # 提交更改 git commit -m \"Add use-github.md\" # 推送到 Fork 仓库 git push origin git-tutorial 这样，远程的 fork 仓库就会多出一个git-tutorial分支，里面有你的更改。\n接下来让我们对源仓库发起 Pull Request。\n请来到fork仓库或者源仓库的 Pull Request 页面，点击右上角的New Pull Request。\n接下来你会来到这个页面：\n请确保 base reposiory是希望接受你的 PR 的仓库 base是接受你的 PR 的分支\nhead repository是你自己的 Fork 仓库 compare是你的分支。\n在我们的例子中， base repository是NEUQ-CS/manual base是master head repository是\u003c你的用户名\u003e/manual compare是git-tutorial\n选择正确后，你会看到你的更改的 diff，确保你的更改是正确的。\n确认完毕后，就可以点击Create Pull Request。\n在这个页面，请填写一个简短的标题和描述，描述你的更改的目的，内容等。\n确保你勾选了Allow edits from maintainers，这样仓库维护者可以直接修改你的 PR。\n然后点击Create Pull Request，就可以发起 Pull Request 了。\n现在你需要做的就是等待仓库维护者审查你的代码，提出修改意见，最终合并你的 PR。\n通常来说，良好的代码风格，清晰的描述，以及正确的更改是被接受的。\n需要注意的是，在打开 Pull Request 后，请尽量不要强制推送到你的分支，这样会导致 PR 的状态不正确。大部分仓库的维护者都会反对强制推送。\n合并 Pull Request 本质是合并两个分支，因此合并 PR 也可能出现合并冲突。如果出现合并冲突，你需要解决冲突。\n关于冲突，我们会在下一讲中详细讲解。","总结#总结":"本文介绍了如何使用 GitHub 进行协同开发，以及对其他项目作出贡献。我们讲解了 Fork 和 Pull Request 的概念，以及如何操作。\n希望你能够通过这篇文章了解 GitHub 的基本操作，以及如何使用 GitHub 对其他项目作出贡献。","添加-ssh-密钥#添加 SSH 密钥":"添加 SSH 密钥是将你的密钥对的公钥添加到 GitHub 上，这样 GitHub 就能够识别你的操作是不是由你的私钥发出的。\n所以现在先来获取你的公钥。\n生成的密钥对默认在~/.ssh/文件夹下，先查看一下：\ncd ~/.ssh \u0026\u0026 ls 根据你使用的加密算法，你会看到id_rsa和id_rsa.pub或者id_ed25519和id_ed25519.pub。.pub后缀的文件就是你的公钥。\ncaiyi@archlinux ~/t/manual (a)\u003e cd ~/.ssh/ \u0026\u0026 ls id_ed25519.pub id_rsa.pub known_hosts.old id_ed25519 id_rsa known_hosts 选择你的公钥文件，打开它，复制里面的内容。\n如果不巧的是，你同时生成了多对密钥，那么你需要找到 Git 使用的是哪一个密钥。或者保险一点，你可以将所有的公钥都添加到 GitHub 上。\n复制完内容以后，在浏览器中打开 https://github.com/settings/keys，点击右侧绿色的New SSH key。\n在 Title 中填写一个用于标识这个密钥的名字，比如My ArchLinux Laptop。确保key type是Authentication key，在 Key 中粘贴你的公钥内容。你的公钥内容应该以你的邮箱结尾，如果不是，要么你复制成了私钥，要么你没有复制完整。\n填写完成后，点击Add SSH key，GitHub 可能会通过各种方式认证你的操作，比如输入密码，输入验证码等等。完成后，你的公钥就添加到了 GitHub 上。","验证-ssh-密钥#验证 SSH 密钥":"通过以下命令验证你的 SSH 密钥是否添加成功：\nssh -T git@github.com 如果提示是否使用 SSH 密钥，请直接回车（同意）。然后你应该会看到类似于以下的输出。\nHi \u003c你的用户名\u003e! You've successfully authenticated, but GitHub does not provide shell access. 如果你看到了这个输出，那么你的 SSH 密钥就和你的 GitHub 账号绑定成功了。"},"title":"开始使用 GitHub"},"/use-git/hug-cli/":{"data":{"":"","#":"本页内容对于新手来说可能有些难度，你不需要理解所有内容，只需要确保你能够看懂命令行，并使用命令行来完成常见工作即可。\n请认真对比命令行的内容和我对内容含义的解释，确保你理解命令行界面的含义。 以下是三种常见的命令行界面，分别是：\nGit Bash on Windows Caiyi Shyu@archlinux MINGW64 ~ $ git --version Bash on Unix [caiyi@archlinux ~]$ git --version Fish on Unix caiyi@archlinux ~\u003e git --version 它们都含有以下几个部分：\nCaiyi Shyu@archlinux 或者 caiyi@archlinux ~ $ 或者 Fish 中的 \u003e git --version 第一个部分是用户名和主机名，格式为\u003c用户名\u003e@\u003c主机名\u003e。\n用户名和主机名 在上面的例子中，用户名是Caiyi Shyu或者caiyi，主机名是archlinux。主机名是你的电脑的名字，在你操作系统的设置中可以找到并进行更改。\n工作目录 第二个部分是工作目录，格式为\u003c工作目录\u003e。在上面的例子中，工作目录是~。~表示用户的home目录，也就是你的用户目录。在 Windows 中，用户的家目录一般是C:\\Users\\\u003c用户名\u003e。在 Unix 中，用户的家目录一般是/home/\u003c用户名\u003e。\n你也可以在终端中输入pwd命令来查看当前工作目录。 以下是在 Windows 和 Unix 中的输出：\nGit Bash on Windows /c/Users/Caiyi Shyu/ 看起来和 Windows 下常见的路径有些不一样。这是因为 Git Bash 使用 Unix 风格的路径。上面的路径等价于C:\\Users\\Caiyi Shyu\\。注意，在Git Bash中，只能使用Unix风格的路径，并且路径分隔符是/而不是\\。\nBash or Fish on Unix /home/caiyi 这是完整目录，当前用户的home就等价于~\n当我进入当前目录下的Desktop目录时，工作目录会变成~/Desktop。\n就像下面一样：\nGit Bash on Windows Caiyi Shyu@archlinux MINGW64 ~/Desktop $ Bash on Unix [caiyi@archlinux ~/Desktop]$ Fish on Unix caiyi@archlinux ~/Desktop\u003e 现在输入pwd命令，你会看到输出是/home/caiyi/Desktop(Linux和macOS)或者/c/Users/Caiyi Shyu/Desktop(Windows)。\n需要说明的是，shell中的工作目录通常为了显示简洁，可能会省略一部分内容。如果你不清楚当前的工作目录，请随时pwd命令来查看。\n提示符 第三个部分是提示符，格式为\u003c提示符\u003e。在上面的例子中，提示符是$或者\u003e。提示符告诉你终端已经准备好接受你的输入了。\n命令 第四个部分是命令，格式为\u003c命令\u003e。在上面的例子中，命令是git --version。这个命令告诉终端你想要执行git这个程序，并且传递了一个参数--version给这个程序。\n命令是你和shell交互的方式。当你输入完命令后，按下回车键，shell会解释1并执行这个命令。\n命令分为两种：内建命令和外部命令。内建命令是shell自带的命令，比如cd，pwd，exit等。外部命令是你安装的程序，比如git，ls，cat等。\nShell 在寻找命令时，会先在内建命令中查找，如果找不到，就会在外部命令中查找。所以，当你尝试执行一个不存在的命令时，shell会提示你command not found，就像下面这样：\n[caiyi@archlinux Desktop]$ firetruck you bash: firetruck: command not found 需要说明的是，只有第一个单词是命令，比如上面的firetruck和git，shell 会去寻找一个叫firetruck或者git的程序。后面的一切都是参数，shell 会把这些参数传递给这个程序。\n例如，在执行git --version时，--version就是参数。程序根据不同的参数执行不同的操作。\n还记得main函数的完整形式？通过argv向量，程序就可以访问到这些参数。\n// 省略了 envp 参数，避免让新手头大 int main(int argc, char *argv[]) { // argc 是参数的数量 // argv 是参数的数组 } 让我们写一个简单的程序来获取所有的参数。\n#include \u003cstdio.h\u003e int main(int argc, char *argv[]) { for (int i = 0; i \u003c argc; i++) { printf(\"argv[%d]: %s\\n\", i, argv[i]); } return 0; } 编译后，我们使用以下参数运行这个程序，可以得到以下输出：\ncaiyi@archlinux ~\u003e ./argv_demo --version argv[0]: ./argv_demo argv[1]: --version 可以看到，--version这个参数被传递给了这个程序。但是值得注意的一点是，第一个参数并不是--version，而是程序的名字。这是因为，程序可能在运行时希望获得自己的完整路径，通过将当前工作目录和程序名拼接起来，程序就可以获得自己的完整路径。\n解释是指shell会根据你输入的命令，找到对应的程序，并且传递参数给这个程序。程序会根据参数执行相应的操作。 ↩︎","基本命令#基本命令":"从现在开始，你就要像一个程序员一样使用命令行了。在这一节中，我们会学习一些基本的命令。\n一般来说，你使用的命令只有两类：\n更改工作目录的命令 执行程序或操作 更改工作目录的命令 更改工作目录的一般使用cd命令。cd是change directory的缩写。\ncd 后既可以接绝对路径，也可以接相对路径。\n使用绝对路径：\ncd /home/caiyi/Desktop 现在你的工作目录就变成了/home/caiyi/Desktop。输入pwd命令，你会看到输出是/home/caiyi/Desktop。同时在提示符附近也可以看到当前工作目录。\n再使用相对路径：\ncd repos/manual 现在你的工作目录就变成了/home/caiyi/Desktop/repos/manual。输入pwd命令，你会看到输出是/home/caiyi/Desktop/repos/manual。\n通常来说，使用相对路径更方便，因为你不需要记住绝对路径。要进入当前工作目录下的一个文件夹，只需要输入cd 文件夹名即可。\n现在来看看..和.的用法。\ncd .. 输入这个命令后，你的工作目录就变成了原来工作目录的上一级目录。输入pwd命令，你会看到输出是/home/caiyi/Desktop/repos。\ncd . 输入这个命令后，你的工作目录不会发生变化。因为.表示当前工作目录。虽然.在现在看起来好像没什么用，但是在某些情况下，.是非常有用的。后面我们会提到。\n执行程序或操作 在命令行中，你可以执行程序或者操作。这些程序或操作可以是内建的，也可以是外部的。\n内建命令 pwd pwd是print working directory的缩写。这个命令会输出当前工作目录的绝对路径。\n样例输出：\npwd 输出的内容是/home/caiyi/。\nls ls是list的缩写。这个命令会列出当前工作目录下的所有文件和文件夹。\n样例输出：\nLICENSE book/ book.toml src/ 这是当前本仓库的根目录的输出。你可以看到有四个文件和文件夹。文件夹都以/结尾，其他的都是文件。\nls命令还有一些选项，常用的有-l和-a。\n-l选项会输出更详细的信息，包括文件的权限，所有者，大小，修改时间等。\n例如：\ncaiyi@archlinux ~/r/manual (use-git)\u003e ls -l total 16 -rw-r--r-- 1 caiyi caiyi 1064 Aug 5 14:57 LICENSE drwxr-xr-x 7 caiyi caiyi 4096 Aug 5 19:03 book/ -rw-r--r-- 1 caiyi caiyi 148 Aug 5 15:29 book.toml drwxr-xr-x 4 caiyi caiyi 4096 Aug 5 18:40 src/ -a选项会输出所有的文件和文件夹，包括隐藏的文件和文件夹。隐藏的文件和文件夹以.开头。\ncaiyi@archlinux ~/r/manual (use-git)\u003e ls -a ./ ../ .git/ .github/ .gitignore LICENSE book/ book.toml src/ 更多的用法请上网查询。\nrm rm是remove的缩写。这个命令会删除文件或者文件夹。\n删除文件 直接输入rm，然后将文件路径作为参数传递给rm。\n例如\nrm LICENSE rm ./LICENSE rm ../LICENSE 删除文件夹 如果一个文件夹不为空，你不能直接删除它。 但是有一个简单的方法可以删除一个文件夹及其所有内容，就是使用-r选项。r是recursive的缩写，表示递归。\nrm -r book/ 这个命令会删除book文件夹及其所有内容。\n网上有很多人开玩笑的让新手输入sudo rm -rf /这个命令，这是相当危险的。它会递归删除根目录下的所有文件和文件夹。包括boot分区和所有数据资料。所以，请不要输入这个命令。\n同时，在删除当前文件夹下所有文件时，有些人喜欢用rm -rf ./，建议不要使用这种方法，而是输入完整的文件夹名字，因为它和上面的命令相似，如果你输入错误，就会发生灾难性的后果。\n删除多个文件 你可以一次删除多个文件。\nrm LICENSE book.toml 这个命令会删除LICENSE和book.toml这两个文件。\nmv mv是move的缩写。这个命令可以移动文件或者文件夹。\nmv LICENSE book/ 这个命令会将LICENSE文件移动到book文件夹下。\nmv book/ book-old/ 这个命令会将book文件夹重命名为book-old。Unix下没有专门的重命名命令，重命名就是移动。\ncp cp是copy的缩写。这个命令可以复制文件或者文件夹。其语法和mv类似。这里不再赘述。\ncp LICENSE book/ 把LICENSE文件复制到book文件夹下。\nmkdir mkdir是make directory的缩写。这个命令可以创建文件夹。\nmkdir new-folder 这个命令会在当前工作目录下创建一个叫new-folder的文件夹。\n创建多级文件夹 mkdir -p new-folder/sub-folder 这个命令会创建一个叫new-folder的文件夹，然后在这个文件夹下创建一个叫sub-folder的文件夹。\ntouch touch命令会创建一个空文件。\ntouch new-file 这个命令会在当前工作目录下创建一个叫new-file的文件。\n外部命令 常用的内部命令就以上这几个，它们覆盖了你在日常工作中的大部分需求。但是有时候你需要使用一些外部命令。\ncat cat是concatenate的缩写。这个命令会输出文件的内容。很多人认为cat是一个内建命令，但是它实际上是一个外部命令。\ncat LICENSE 这个命令会输出LICENSE文件的内容。 例如：\ncaiyi@archlinux ~/r/manual (use-git)\u003e cat LICENSE MIT License Copyright (c) 2024 NEUQ-CS Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. echo echo命令会输出参数。\necho \"Hello, World!\" 这个命令会输出Hello, World!。\n其他命令 对于其他命令，只要它在环境变量PATH中，你就可以直接使用。使用echo $PATH，你可以看到PATH中包含了哪些路径。这些路径就是系统用来查找命令的路径。在这些路径下的可执行文件都可以直接使用。\n我们使用的git命令就是一个外部命令。如果是 Unix 系统，git 在/usr/bin或者/usr/local/bin中会有一个链接指向真正的可执行文件。在 Windows 系统中，git 会被安装到C:\\Program Files\\Git\\bin中或者你自己指定的路径。\n如果你不知道一个命令是不是内建命令，你可以使用which命令来查找。\n运行任意程序 前面我们讲了运行在环境变量PATH中的程序。但是有时候你需要运行一个不在PATH中的程序。比如你用gcc在当前目录下编译了一个程序，你显然不会先把当前目录加入PATH再运行这个程序。\n这时候你可以使用相对路径或者绝对路径来运行这个程序。\n对于非当前目录下的程序，你可以使用相对路径或者绝对来运行，例如：\n# 使用绝对路径 caiyi@archlinux ~\u003e ~/argv_demo --version # 使用相对路径 caiyi@archlinux ~\u003e ../tmp/argv_demo --version 对于当前目录下的程序，这时候就需要使用.了。你需要使用./\u003c程序名\u003e来运行这个程序，例如：\ncaiyi@archlinux ~\u003e ./argv_demo --version 这是为了避免歧义，如果不输入./，这种格式完全符合命令的格式，因此shell会把它当作命令来执行。\n权限问题 在 Unix 系统中，程序需要有执行权限（Executable）才能运行。有时你从网上下载了一个二进制文件，你发现你不能运行它，这是因为它没有执行权限。\n这时候就需要使用chmod命令来添加执行权限。\nchmod +x argv_demo 这样你就可以运行这个程序了。\nUNIX的权限分为可读可写可执行三种权限，分别用r，w，x表示。对于文件夹，x表示可以进入这个文件夹。也可以使用三个比特二进制表示：\n000 其中第一个比特表示可执行权限，第二个比特表示可写权限，第三个比特表示可读权限。\n当权限为0时表示为既不可读也不可写也不可执行。当权限为7时表示可读可写可执行。\n链接 在 Unix 系统中，有两种链接：符号链接（也叫软链接）和硬链接。\n它们都是一种特殊的文件，它们指向另一个文件。软链接在 Windows 下叫做快捷方式。软链接在 Unix 下有两种，一种是符号链接，另一种是硬链接。符号链接是一种特殊的文件，它指向另一个文件。硬链接是一个文件的另一个名字。\n指向意味着，当你访问这个链接时，实际上你访问的是被链接的文件。这样，你可以在不改变文件的情况下，改变文件的位置。同时，你也可以在不占用额外空间的情况下，创建一个文件的副本。\n环境变量 环境变量是一种特殊的变量，它们是在操作系统启动时设置的。环境变量是一个键值对。键是环境变量的名字，值是环境变量的值。\n对于新手来说，你只需要了解两个环境变量：PATH和HOME。\nPATH是一个包含了系统用来查找命令的路径的变量。当你输入一个命令时，系统会在PATH中的路径下查找这个命令。如果找到了，就会执行这个命令。如果没有找到，就会提示command not found。\nHOME是用户的家目录。在 Unix 系统中，用户的家目录一般是/home/\u003c用户名\u003e。前面说的~是家的别名是不准确的，事实上，它是HOME环境变量的值。如果你修改了HOME环境变量，~也会随之改变。\n你可以使用echo命令来查看环境变量的值。\necho $PATH ‘$‘符号是一个特殊字符，它表示后面的是一个变量。在这个例子中，$PATH表示PATH环境变量的值。\n在 C 语言中的完整main函数的形式是这样的：\nint main(int argc, char *argv[], char *envp[]) { // argc 是参数的数量 // argv 是参数的数组 // envp 是环境变量的数组 } 是的，这才是完整的main函数，它接受3个参数而不是大多数教程中的2个参数。\n遍历envp向量即可得到所有的环境变量。环境变量向量可能非常长，因此在这里不再展示。\n环境变量以及参数都是父进程在变为子进程时通过exec系统调用让操作系统传递给子进程的。并且argc,argv,envp是子进程主线程线程栈最顶端的元素。\n命令的选项 命令的选项也是一种参数，但是它们以-或者--开头。选项可以改变命令的行为。\n-选项是单字母的选项，--选项是多字母的选项。\n对于某些程序，例如ls，-选项可以合并，比如-a -l可以写成-al。\n一般来说，对大部分程序使用-h或者--help选项可以查看帮助信息。\n选项分为两种：有参数的选项和无参数的选项。有参数的选项后面需要跟一个参数，无参数的选项不需要。\n上面提到的--help就是是无参数的选项。\n例如，某款游戏可能接受--fullscreen true这样的选项，--fullscreen是有参数的选项，true是这个选项的参数。但是它们都是命令中的参数。\n管道 管道是Unix中较为复杂的概念，在这里我只讲如何使用。\n管道的作用是重定向命令的输出。你可以把一个命令的输出作为另一个命令的输入。也可以把一个命令的输出保存到文件中。\n重定向到另一个程序的标准输入 echo \"Hello, World!\" | cat 首先，echo \"Hello, World!\"会输出Hello, World!。然后，|会把这个输出重定向到cat命令的标准输入。cat会输出这个输入。所以输出还是Hello, World!。\n重定向到文件 echo \"Hello, World!\" \u003e hello.txt 这个命令会把echo \"Hello, World!\"的输出重定向到hello.txt文件中。\u003e是重定向的符号。\n现在你可以使用cat命令查看这个文件的内容。\ncat hello.txt 重定向到文件的末尾 echo \"Hello, World!\" \u003e\u003e hello.txt 这个命令会把echo \"Hello, World!\"的输出追加到hello.txt文件的末尾。\u003e\u003e是追加重定向的符号。","认识路径#认识路径":"以这个路径为例：/home/caiyi/Desktop。\n路径表示文件系统中的位置，既可以是文件夹，也可以是文件。\n路径分为绝对路径和相对路径。在Unix风格的路径中，判断一个路径是绝对路径还是相对路径很简单：如果路径以/开头，那么这个路径就是绝对路径，否则就是相对路径。\n绝对路径是从根目录开始的路径，相对路径是相对于当前工作目录的路径。\n看到一个路径，请你的大脑将这个路径按’/‘分割成一个数组：['home', 'caiyi', 'Desktop']。\n除最后一个元素外，每个元素都是一个文件夹。最后一个元素既可以是文件夹也可以是文件。但是如果最后一个元素后面还跟了一个/，那么这个元素就是一个文件夹。\n上面的例子中，由于是一个绝对路径，所以它的含义是 根目录下的home文件夹下的caiyi文件夹下的Desktop文件夹（或文件夹）。\n下面来看一个相对路径的例子：repos/manual/\n这个路径是相对路径，因为它不是以/开头的。这个路径的含义是当前工作目录下的repos文件夹下的manual文件夹1。\n特殊的路径 前面介绍了/和~这两个特殊的路径。它们分别表示根目录和用户的家目录。\n/是根目录，是文件系统的最顶层。在 Unix 系统中，所有的文件和文件夹都是从根目录开始的。\n~是用户的家目录，是用户的默认工作目录。在 Unix 系统中，用户的家目录一般是/home/\u003c用户名\u003e。\n下面再介绍两个特殊的路径：.和..。\n.表示当前工作目录，是一个相对路径。例如，./repos表示当前工作目录下的repos文件夹。它就等价于repos。\n..表示上一级目录，是一个相对路径。例如，../repos表示当前工作目录的上一级目录下的repos文件夹。\n前面说了，如果最后一个元素后面还跟了一个/，那么这个元素就是一个文件夹。 ↩︎"},"title":"认识命令行"},"/use-git/installation/":{"data":{"":"前文提到，Git可以在任何操作系统上运行。那么，本文将讲解在 Windows, Linux，以及 macOS 上如何安装 Git。\n安装的部分大家跳转到适合自己操作系统的部分即可。","linux#Linux":"跳转到你的发行版的部分，按照你的发行版安装即可。\nArch Linux sudo pacman -S git Debian/Ubuntu sudo apt install git Fedora sudo dnf install git openSUSE sudo zypper install git Gentoo 自己编译去吧。","macos#macOS":"macOS 是基于 Unix 的操作系统，因此安装 Git 就像在 Linux 下安装软件一样简单。不过macOS不自带有包管理器，因此你需要自己安装一个包管理器。这里推荐使用 Homebrew。\n使用 Homebrew brew install git ","windows#Windows":"Windows 下安装Git稍微麻烦一些，因为Git本身是一个命令行工具，而Windows下的用户对命令行的使用并不是很熟悉，同时Windows下的命令行工具也跟垃圾一样难用。不过如果你会一点点命令行，并且有使用包管理器，你可以跳转到使用包管理器安装的部分。其他人就别看了，直接去手动安装部分吧。\n需要说明的是，使用包管理器和手动安装，都是使用相同的软件来源，只是安装方式不同。因此效果是一样的。\n使用包管理器 如果你有使用 winget 包管理器，那么安装 Git 就像和在 Linux 下安装软件一样简单。Windows下有很多种包管理器，下面介绍两种最常见的包管理器winget 和 scoop上安装Git。\n使用 winget 使用以下命令安装 Git：\nwinget install --id Git.Git -e --source winget 使用 scoop 使用以下命令安装 Git：\nscoop install git 手动安装 前往Git for Windows官网。你应该会看到和下图类似的页面：\n现在，你需要根据你的机器选择合适的架构1。对于大多数电脑用户来说，尤其是对于 Windows 10及以上的用户，选择64-bit即可。这些操作系统都是64位的。只要你的电脑不是十几年前的，一般都是64位的。\n不过，即使你不知道自己的电脑是什么架构，也不用担心。Git官网自动帮你检测了你的电脑架构，你只需要点击巨大的Download for Windows标题下的Click here to download超链接即可。\n下载完成后，双击下载的安装包，打开安装文件，你需要在下面几个页面注意一下选项，其他地方一路Next即可。一定要先看完再安装，不然后悔莫及。\n我的图片是在Linux下使用Wine打开的，所以某些字体可能会有点问题，但是不影响理解。\n添加 Git Bash 到 Windows Terminal 勾选倒数第二个选项(New) Add a Git Bash Profile to Windows Terminal。前面说过，Git 是一个命令行工具，而 Git Bash 是一个包含了Git的shell。这个选项会把 Git Bash 添加到 Windows Terminal 中，这样你就可以直接在 Windows Terminal 中使用 Git Bash 了。\nShell2 是一个命令行解释器，它是一个程序，用于解释用户输入的命令，并执行这些命令。Windows下的命令行解释器是cmd和Powershell，而Git Bash是一个基于bash的Shell。\n我们使用 Windows Terminal 是因为它是一个终端模拟器，可以同时打开多个终端，而且可以在一个窗口中同时打开不同的Shell。这样，你就可以在一个窗口中同时使用cmd，Powershell，Git Bash等Shell了。同时，Windows Terminal也能更好地支持复制粘贴等操作。\n选择默认编辑器 这个选项是选择你的默认编辑器。Git 会在一些情况下打开一个编辑器。大多数 Unix 用户都使用Vim/Neovim作为编辑器。但是，如果你不会/根本不知道Vim，请千万不要使用Vim。根据我的经验来看，大多数用户进入Vim后都不知道怎么退出。所以，请选择你在外部使用的编辑器，比如VS Code。如果没有，建议安装一个。实在不写可以使用Nano，这也是一个命令行的编辑器，但是它的操作都傻瓜式地写在屏幕下面了。\n选择默认换行符 你可能听说过 Unix 系统使用\\n作为换行符，Windows 使用\\r\\n作为换行符。这个选项就是选择你的默认换行符。请一定Checkout as-is, commit Unix-style line endings即可。这个选项会在你检出代码时，使用Unix风格的换行符，提交代码时，使用Unix风格的换行符。否则，你在提交代码的时候很可能产生一大堆更改，因为换行符不同。\n启用软链接 把第二个选项Enable symbolic links勾选上。\n软链接是一种特殊的文件，它指向另一个文件。软链接在Windows下叫做快捷方式。软链接在Unix下有两种，一种是符号链接，另一种是硬链接。符号链接是一种特殊的文件，它指向另一个文件。硬链接是一个文件的另一个名字。软链接在Windows下叫做快捷方式。这个选项是启用符号链接，这样你就可以在Git中使用软链接了。后面我们会稍微提到软链接，现在你你不许要知道这是什么。\n接下来你就可以一路Next了。\n安装完成后，在任意文件夹中按住shift，右键点击鼠标，你会看到在此处打开 Git Bash或者Open Git Bash here。点击这个选项，你就可以在当前文件夹中打开 Git Bash 了。\n你也可以使用Windows Terminal，请先按照以下视频添加Git Bash的配置。\n你需要在网页版阅读本文才能看到视频。\n不同的架构使用不同的CPU指令集，因此选择错误的架构会导致Git无法运行。 ↩︎\n更准确地说，Git Bash是一个阉割版的 msys2，msys2和cygwin都是在Windows上提供类Unix环境的软件。bash是Unix上最常用的Shell之一。所以，Git Bash就是一个阉割后，只安装了Git和bash的msys2。 ↩︎","结束#结束":"安装完成后，你可以打开终端，输入git --version，然后回车，看到类似以下输出，说明安装成功：\ncaiyi@archlinux ~\u003e git --version git version 2.45.2 下一讲，我们将讲解如何配置 Git，以及简要介绍命令行和shell的基本操作。"},"title":"安装 Git"},"/use-git/try-git/":{"data":{"":"在了解了命令行的基本操作后，我们来尝试使用 Git。这部分的内容是命令和原理结合的，你可以在这里学到 Git 的基本操作和 Git 的工作原理。\n获得一个 Git 仓库的方法有两种，一种是“将一个文件夹变成 Git 仓库”，一种是从远程克隆一个 Git 仓库。","克隆远程仓库#克隆远程仓库":"要从远程克隆仓库首先要确保你具有权限，对于 GitHub，GitLab, Bitbucket等代码托管平台的公开仓库，任何人都具有权限，因此可以直接克隆。对于私有仓库，你需要一个具有读取权限的平台账号，然后将平台账户和你的 SSH 密钥绑定。\n具有权限后，就能够克隆仓库了，使用以下命令即可：\ngit clone https://github.com/NEUQ-CS/manual.git 记得将仓库地址更换成你想克隆的仓库的地址。克隆结束后，在当前目录下会产生一个与仓库名一致的文件夹，在本例中，是manual。 这个仓库就是你克隆的 Git 仓库。\nclone命令还有一些其他参数可以使用\n克隆到指定文件夹 在地址后面加上指定路径即可：\ngit clone https://github.com/NEUQ-CS/manual.git path/to/repo 注意，仓库里的文件会直接存在你指定的文件夹里面，而不是在你指定的目录里放仓库文件夹。\n克隆指定分支 加上参数-b \u003c分支名\u003e即可，例如:\ngit clone https://github.com/NEUQ-CS/manual.git -b master 这将指定需要克隆master分支.\n需要说明的是，即使你选择了一个分支，整个仓库的所有分支都实质上会被克隆下来，只是克隆完成后位于指定分支。\n指定克隆深度 使用--depth \u003c深度\u003e来指定克隆深度：\ngit clone https://github.com/NEUQ-CS/manual.git --depth=1 仅克隆主分支上包含最新一个提交的完整仓库，克隆的仓库不含有任何历史记录。不推荐使用，除非你只是为了临时下载代码并且不需要历史记录和其他分支。","将一个文件夹变成一个-git-仓库#将一个文件夹变成一个 Git 仓库":"Git 仓库的本质是一个文件夹。所以，我们可以将一个文件夹变成一个 Git 仓库。\n你可以输入以下命令，把当前文件夹变成一个 Git 仓库：\ngit init 或者，你可以输入以下命令，把指定文件夹变成一个 Git 仓库：\ngit init path/to/folder Git 仓库和普通文件夹的区别在于，Git 仓库中有一个隐藏的.git文件夹，这个文件夹中存储了 Git 的所有信息，包括所有的git object，ref等。在任何情况下，你都不要应该修改.git文件夹中任何的内容。唯一的例外是.git/config文件，这个文件存储了当前仓库的配置信息，例如远程仓库的地址等。但是你也应该谨慎修改这个文件或者使用git config命令修改配置。\n如果你不小心把一个文件夹变成了 Git 仓库1，直接删除.git文件夹就可以了。使用以下命令即可：\nrm -rf .git Git 在操作 Git 仓库时，会递归的从当前文件夹向上查找.git文件夹，直到找到第一个.git文件夹或者到达文件系统的根目录。所以，你可以在任何一个 Git 仓库的子文件夹中使用 Git 命令。当 Git 仓库嵌套时，Git 会使用离当前文件夹最近的.git文件夹。\n去年有人才把整个C盘或者桌面都变成了Git仓库。 ↩︎","常见误区#常见误区":"Git 命令行 一般情况下仅在本地管理仓库，不会实时修改远程仓库。当且仅当执行以下命令时会通过网络与远程仓库交互：\ngit fetch 和 git pull 执行这两个命令时，仅会读取远程仓库的信息，不会修改远程仓库的信息。git fetch会将远程仓库的信息拉取到本地仓库，git pull会将远程仓库的信息拉取到本地仓库并合并到当前分支。\ngit push 执行这个命令时，会将本地仓库的信息推送到远程仓库，这会修改远程仓库的信息。","总结#总结":"本节课我们学习了 Git 的基本操作，包括将一个文件夹变成 Git 仓库，克隆远程仓库，查看 Git 仓库的状态，提交代码，查看提交历史，推送到远程仓库，拉取远程仓库的修改，分支的创建，切换，删除，合并，变基等操作。\n这些操作需要你多加练习，只有多加练习，你才能熟练掌握这些操作。\n要练习这些操作，我推荐使用这个网站：Learn Git Branching。使用这个网站时，你只需要先掌握基本操作，以及操作远程仓库的操作，就可以了。对于更加复杂的操作，等你对 Git 有了更深的理解再去尝试。\n但更重要的是，你应该多使用 Git 来管理你的代码，这样你才能更好地理解 Git 的工作原理。\n下一节课开始，我们将学习如何使用代码托管平台，本教程以 GitHub 为例。","查看-git-仓库的状态#查看 Git 仓库的状态":"在一个 Git 仓库中，你可以使用以下命令查看当前仓库的状态：\ngit status 你会看到以下输出：\nOn branch master Your branch is up to date with 'origin/use-git'. Changes to be committed: (use \"git restore --staged \u003cfile\u003e...\" to unstage) modified: src/use-git/configure.md Untracked files: (use \"git add \u003cfile\u003e...\" to include in what will be committed) src/use-git/try-git.md 当前在分支master上，你的分支是最新的。Changes to be committed中列出了你修改的文件，Untracked files中列出了你新建的文件。\nGit 工作原理 在继续尝试前，我们先来了解一下 Git 的工作原理，你可能已经对上面的输出感到迷惑了。\n在一个 Git 仓库的文件夹中，一个文件可能存在以下三种状态的其中一种：\n未跟踪　Untracked 已跟踪 Tracked 暂存中 Staged 未跟踪 当你使用 git init初始化一个仓库时，原有的所有文件都是未跟踪。Git 不会管理任何未跟踪的文件，但是这个文件仍然存在于这个文件夹中。不会管理的意思在于，当你通过 git 操作仓库的状态时，未跟踪的文件不会被修改或删除。如果一定会造成修改1，git 会阻止这次操作，直到你解决完冲突。\n已跟踪 这应该是仓库中大部分文件存在的状态。当你刚远程克隆完一个仓库时，所有文件都处于已跟踪状态。这是显然的，因为只有被跟踪的文件才会被提交到远程服务器。\n跟踪未跟踪的文件 要把一个未跟踪的文件变为已跟踪状态的方法是，先添加到暂存区，然后再commit。以下是命令行教程\n# 添加a_new_file到暂存区 git add a_new_file # commit在暂存区的所有文件 git commit -m \"add `a_new_file` to this repo\" 将已跟踪的文件删除 你可以使用git rm \u003c文件\u003e来删除，这会直接把删除操作直接添加到暂存区，文件系统上的文件也会被删除。它等价于以下操作：\nrm an_old_file git add an_old_file 要取消跟踪一个文件，但希望在文件系统上保留这个文件，使用git rm --cached file\n暂存中 准确地说，暂存的不是文件，是操作。通常来说，可以暂存\n修改 Modify/Update 添加 Add 删除 delete 移动 Move 这几种操作。\n当你在文件系统上修改一个文件，然后用git add的时候会暂存一个修改操作到暂存区。 当你在文件系统上添加一个文件，然后用git add的时候会暂存一个添加操作到暂存区。 当你在文件系统上删除一个文件，然后用git add的时候会暂存一个删除操作到暂存区。 当你在文件系统上移动或重命名一个文件，然后用git add的时候会暂存一个移动操作到暂存区。\n将操作从暂存区撤出，使用以下命令：\ngit restore --staged file 对于这些状态的理解，我推荐使用Visual studio code的内置Git功能进行观察，他是Git的一个前端。可以代替手动的命令行，但是，就我个人而言，更会倾向使用命令行，因为这些前端不支持较为复杂的操作。\n现在我们再来看这段输出：\nOn branch master Your branch is up to date with 'origin/use-git'. Changes to be committed: (use \"git restore --staged \u003cfile\u003e...\" to unstage) modified: src/use-git/configure.md Untracked files: (use \"git add \u003cfile\u003e...\" to include in what will be committed) src/use-git/try-git.md Changes to be committed部分就是存在于暂存区的文件，当我们使用git commit的时候，就会跟踪并把这些文件添加到git仓库。\nUntracked files是前文说过的未跟踪文件，这是因为这个文件才创建，当使用git add来添加时，会在暂存区添加一个添加操作。\n代码提交 代码提交使用git commit命令，提交的时候需要一段简短的话描述你的这次修改。同时，你的姓名，邮箱也会被记录在这条commit记录中。\n关于如何编写commit信息，我会在后面讲解良好的git使用习惯时讲到。\ngit commit命令常用的形式有以下两种：\n将信息作为参数直接提交 git commit -m \"\u003c提交信息\u003e\" 使用代码编辑器编写提交信息 git commit -a 这会打开你在安装时选择的代码编辑器，信息编写完成后，保存关闭即可。\n有时候，你觉得提交信息写的不好，打算重写编写提交信息时，可以采用以下命令：\ngit commit --amend -m \"\u003c提交信息\u003e\" 或者使用编辑器\ngit commit --amend -a 这会完全重新提交一次commit并获得不同的commit哈希2，以及时间戳。\n使用git commit --amend的操作等价于以下操作：\n# 保留修改回到上一次提交 git reset --soft \"HEAD^\" # 重新提交 git commit -m \"\u003c提交信息\u003e\" 我个人更喜欢这种方法，因为更为灵活，你可以在重新提交过程中做一些修改。\n查看提交历史 使用git log命令可以查看提交历史，这会列出所有的提交记录，包括提交哈希，提交信息，提交时间，提交者等信息。\n推送到远程仓库 尽管我还没有教你配置远程仓库，但是我还是会告诉你如何推送到远程仓库。\n使用git push命令可以将本地仓库的修改推送到远程仓库。这个命令的形式是：\ngit push \u003c远程仓库名\u003e \u003c本地分支\u003e:\u003c远程分支\u003e 通常来说，远程仓库名是origin。并且，大多数时候，本地分支和远程分支是一样的，所以可以省略远程分支：\ngit push origin \u003c分支\u003e 这会将本地分支推送到远程分支，如果远程分支不存在，会自动创建。\n有时候，远程分支上包含了你不希望存在的修改，这时候你想用本地分支覆盖远程分支，可以使用-f参数：\ngit push -f origin \u003c分支\u003e -f选项会强制推送，这会覆盖远程分支上的所有修改，所以请谨慎使用。如果你把别人的代码或者作业给覆盖了，小心被打。\n在推送之前，你需要先确保你具有远程仓库的所有历史记录，如果本地仓库不包含远程仓库存在的一些更改，你就需要先拉取远程仓库的更改。\n拉取远程仓库的修改 拉取远程仓库的修改使用git pull命令，这会将远程仓库的修改拉取到本地仓库。这个命令的形式是：\ngit pull \u003c远程仓库名\u003e \u003c远程分支\u003e:\u003c本地分支\u003e 同样，大多数时候，远程仓库名是origin，远程分支和本地分支是一样的，所以可以省略远程分支：\ngit pull origin \u003c分支\u003e 这会将远程分支拉取到本地分支，如果本地分支不存在，会自动创建。\ngit pull命令实际上是git fetch和git merge的组合，git fetch会将远程仓库的修改拉取到本地仓库，但不会应用更改，而是会在一个\u003c远程名\u003e/\u003c分支名\u003e的分支上保存，git merge会将这个特殊分支合并到本地分支。\n分支 前面提到了那么多关于分支的内容，但是我还没有告诉你什么是分支。\n分支是 Git 的一个重要概念，它是一个指向一个提交的指针。在一个 Git 仓库中，你可以有多个分支，每个分支指向一个提交。默认情况下，你会有一个master3分支。\n分支的意义在于它和其他分支可以并行开发，你可以在一个分支上开发一个新的功能，而不影响其他分支。当你开发完成后，你可以将这个分支合并到主分支上。合并会将当前分支上所有领先于基础分支的patch应用到基础分支上。这就是使用 Git 进行协作开发的原理。\n了解了什么是分支，现在我来教你如何管理分支。\n查看分支 使用git branch命令可以查看当前本地仓库的所有分支。加上-a参数可以查看所有分支，包括远程分支。\n样例输出：\ncaiyi@archlinux ~/r/manual (use-git)\u003e git branch fix-ci fix-format main master * use-git caiyi@archlinux ~/r/manual (use-git)\u003e git branch -a fix-ci fix-format main master * use-git remotes/origin/HEAD -\u003e origin/main remotes/origin/fix-ci remotes/origin/fix-format remotes/origin/main remotes/origin/master remotes/origin/use-git 上面的输出表明，我们当前在use-git分支上，本地仓库中有fix-ci, fix-format, main, master, use-git五个分支，远程仓库中有fix-ci, fix-format, main, master, use-git五个分支。\n创建分支 创建分支是创建当前分支的拷贝，因此要先切换到你想要拷贝的分支上，然后使用命令。\n创建分支有两种命令：\ngit checkout -b \u003c分支名\u003e git branch -m \u003c分支名\u003e 这会创建一个新的分支，并切换到这个分支上。\n要创建一个分支但不切换到这个分支上，可以使用以下命令：\ngit branch \u003c分支名\u003e 切换分支 当两个分支里的文件不一样时，切换分支会修改当前文件系统上的文件，因为切换分支意味着你要切换到另一个分支的文件系统状态。\n切换分支使用git checkout命令，这会将当前分支切换到指定分支上：\ngit checkout \u003c分支名\u003e 删除分支 删除分支使用git branch -d命令，这会删除指定分支：\ngit branch -d \u003c分支名\u003e 如果分支上有未合并的修改，Git 会拒绝删除这个分支。如果你确定要删除这个分支，可以使用-D参数：\ngit branch -D \u003c分支名\u003e 合并分支 合并分支有三种方法：\n合并 merge 变基 rebase 快进 fast-forward 通常来说，使用merge即可，但是在一些特殊情况下，你可能需要使用rebase。快进是一种特殊的合并，当你的分支是基于基础分支的最新提交时，Git 会直接将基础分支指针指向当前分支指针，这就是快进。\n合并分支使用git merge命令，这会将指定分支合并到当前分支上：\ngit merge \u003c另一个分支\u003e 合并分支会产生一个新的提交commit，这个提交包含了两个分支的所有修改。\n变基 变基是一个相对复杂的概念，相对于merge来说，它能够让提交记录更加线性。这是因为，在合并后，分支继承了基础分支，也同时继承了合并分支，同时具有两个父节点。这会使得提交记录变得复杂，也就是更加不线性。\n变基与合并不同的地方在于，它不会让分支同时继承两个父节点，而是将合并分支的提交记录放在基础分支的最新提交之后。提供更改的分支不会被继承，因而不会出现两个父节点。\n变基使用git rebase命令，这会将指定分支变基到当前分支上：\ngit rebase \u003c另一个分支\u003e 变基会产生一个新的提交commit，这个提交包含了两个分支的所有修改。\n回退到某一个提交 有时候，你可能需要回退到某一个提交，这时候你可以使用git reset命令。命令的格式为\ngit reset [option] \u003c提交哈希\u003e 其中option有以下几种：\n--soft 仅仅回退HEAD指针，不会修改暂存区和工作区 --mixed 回退HEAD指针和暂存区，不会修改工作区 --hard 回退HEAD指针，暂存区和工作区 通常情况下，建议显式指定选项，以避免错误使用命令。\n提交哈希可以使用git log查看。当你想从当前版本向前回退几个版本时，可以使用HEAD~n，其中n是你想回退的版本数。\n例如：\n# 回退到上一个版本 git reset --hard HEAD~ # 回退到上上一个版本 git reset --hard HEAD~2 比如你有一个未跟踪的a.txt，然后你通过切换到另一个分支，合并另一个分支，拉取远程尝试覆盖（其他分支上存在已跟踪的a.txt）这个文件时，Git 会阻止这次操作。 ↩︎\n还记得 Git 是去中心化这句话吗？使用哈希来描述对象是去中心化的典型特征。哈希是指向去中心化网络中对象的一个指针，具有这个指针就能够访问到这个对象，当没有人持有哈希时，这个对象就视为被删除，但是这个对象本身实际上不能被删除，它仍存在于去中心化网络中。Git 的commit也是，这也就意味着，当你在GitHub上删除一个仓库，分支时，它实际上从未被删除，也不能够被删除。 ↩︎\n前几年由于一些政治正确的原因，在GitHub上，主分支被改成了main ↩︎"},"title":"Git 入门"},"/use-git/whatis/":{"data":{"":"你在任何地方都可以找到这样一句话\nGit 是一个分布式版本控制系统，由 Linus Torvalds 于 2005 年创建。Git 是一个免费开源的软件，可以在任何操作系统上运行。\n这是正确的，但是作为一个新手来说，这句话可能并不是很容易理解。你不知道什么叫“分布式”，“版本控制系统”又是什么意思。甚至，你连 Git 有什么作用都不知道。\n所以，让我们从一个简单的例子开始，来看看 Git 是如何工作的。","一个简单的例子#一个简单的例子":"假设我们有一个项目，通常来说，一个项目就是一个文件夹，里面有很多文件。这些文件是项目所需的代码，构建脚本，文档等等一切相关的东西。\n现在来看这个项目，这是一个 C# 项目，你不需要了解 C#，只需要知道这是一个项目就可以了。\n现在打开 Program.cs ，这是一个 C# 项目的入口文件，里面有一个简单的代码：\nConsole.WriteLine($\"Sum from 1 to 100 is {SumFrom1ToN(100)}\"); int SumFrom1ToN(int n) { int sum = 0; for (int i = 1; i \u003c= n; i++) { sum += i; } return sum; } 你一看就知道，这是一个计算从 1 加到 100 的和的程序。你很好奇你的前辈为什么跟个弱智一样要手动从 1 加到 100。因为学过小学的都知道使用高斯公式就可以算出来，于是你决定进行修改：\nConsole.WriteLine($\"Sum from 1 to 100 is {SumFrom1ToN(100)}\"); int SumFrom1ToN(int n) { return n * ((n + 1) / 2); } 然后把代码提交到了项目中。\n不久，测试气冲冲地跑过来给了你一巴掌，因为(n + 1)是奇数时，结果会出错。现在需要fallback到原来的代码，但是不巧的是，没人记得原来的代码是什么样的了。\n这时候，Git 就派上用场了。\nGit 的作用是记录项目的历史，你可以在任何时候回到过去，查看项目的历史状态。这就好比是一个时间机器，你可以随时回到过去，查看项目的状态。每个状态被称为一个commit。当所有状态都被记录下来，你就可以随时回到任何一个状态。就不会出现像上面的情况了。\n有人说，那我直接复制一份项目不就行了吗？实在行我就手动一条一条地改回去。这样不就可以了吗？\n先别急，版本控制只是 Git 最基础的一个功能，但是 Git 的功能远远比这强大。最重要的功能是协同工作。\ncommit的实质是一个patch，它记录了你对项目的哪些文件删除了哪些行，增加了哪些行。\n比如，上文中你提交的代码的commit是这样的：\ndiff --git a/Program.cs b/Program.cs index c677648..1d522bd 100644 --- a/Program.cs +++ b/Program.cs @@ -3,12 +3,5 @@ Console.WriteLine($\"Sum from 1 to 100 is {SumFrom1ToN(100)}\"); int SumFrom1ToN(int n) { - int sum = 0; - - for (int i = 1; i \u003c= n; i++) - { - sum += i; - } - - return sum; + return n * ((n + 1) / 2); } 在 markdown 渲染下，你应该能清楚的理解我们所做的一切，修改发生在Program.cs，我们删除了 int sum = 0; 到 return sum; 这段代码，增加了 return n * ((n + 1) / 2); 这段代码。虽然还有些东西你看不懂，但是不要紧，我们后面会讲到。\n这段patch可以被应用到任何一个拥有相同文件的项目上，而不仅仅是你的项目。当应用patch时，Git 会自动匹配相应的文件和代码行，然后应用patch。\n当你的同伴在修改了项目的其他代码，比如在一开始加了一条Console.WriteLine(\"Hello, world!\")，但是只要被应用patch的代码没有冲突，你的修改就可以被应用到项目上。\n这就是 Git 的强大之处，它可以让你和你的同伴协同工作，而不会出现代码丢失。\n至于冲突发生的时间，冲突的解决，我们后面会讲到。\n接下来应该让你亲手体验一下 Git 的强大之处了，让我们准备安装 Git 吧。"},"title":"初识 Git"}}